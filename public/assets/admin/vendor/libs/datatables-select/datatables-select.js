(function(e, a) { for(var i in a) e[i] = a[i]; }(window, /******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, { enumerable: true, get: getter });
/******/ 		}
/******/ 	};
/******/
/******/ 	// define __esModule on exports
/******/ 	__webpack_require__.r = function(exports) {
/******/ 		if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 			Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 		}
/******/ 		Object.defineProperty(exports, '__esModule', { value: true });
/******/ 	};
/******/
/******/ 	// create a fake namespace object
/******/ 	// mode & 1: value is a module id, require it
/******/ 	// mode & 2: merge all properties of value into the ns
/******/ 	// mode & 4: return value when already ns object
/******/ 	// mode & 8|1: behave like require
/******/ 	__webpack_require__.t = function(value, mode) {
/******/ 		if(mode & 1) value = __webpack_require__(value);
/******/ 		if(mode & 8) return value;
/******/ 		if((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;
/******/ 		var ns = Object.create(null);
/******/ 		__webpack_require__.r(ns);
/******/ 		Object.defineProperty(ns, 'default', { enumerable: true, value: value });
/******/ 		if(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));
/******/ 		return ns;
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";
/******/
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = "./libs/datatables-select/datatables-select.js");
/******/ })
/************************************************************************/
/******/ ({

/***/ "./libs/datatables-select/datatables-select.js":
/*!*****************************************************!*\
  !*** ./libs/datatables-select/datatables-select.js ***!
  \*****************************************************/
/*! no exports provided */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var datatables_net_select_js_dataTables_select__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! datatables.net-select/js/dataTables.select */ \"./node_modules/datatables.net-select/js/dataTables.select.js\");\n/* harmony import */ var datatables_net_select_js_dataTables_select__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(datatables_net_select_js_dataTables_select__WEBPACK_IMPORTED_MODULE_0__);\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9saWJzL2RhdGF0YWJsZXMtc2VsZWN0L2RhdGF0YWJsZXMtc2VsZWN0LmpzPzM1YzkiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUE7QUFBQTtBQUFBIiwiZmlsZSI6Ii4vbGlicy9kYXRhdGFibGVzLXNlbGVjdC9kYXRhdGFibGVzLXNlbGVjdC5qcy5qcyIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCAnZGF0YXRhYmxlcy5uZXQtc2VsZWN0L2pzL2RhdGFUYWJsZXMuc2VsZWN0JztcclxuIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./libs/datatables-select/datatables-select.js\n");

/***/ }),

/***/ "./node_modules/datatables.net-select/js/dataTables.select.js":
/*!********************************************************************!*\
  !*** ./node_modules/datatables.net-select/js/dataTables.select.js ***!
  \********************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;/*! Select for DataTables 1.3.4-dev\n * 2015-2021 SpryMedia Ltd - datatables.net/license/mit\n */\n\n/**\n * @summary     Select for DataTables\n * @description A collection of API methods, events and buttons for DataTables\n *   that provides selection options of the items in a DataTable\n * @version     1.3.4-dev\n * @file        dataTables.select.js\n * @author      SpryMedia Ltd (www.sprymedia.co.uk)\n * @contact     datatables.net/forums\n * @copyright   Copyright 2015-2021 SpryMedia Ltd.\n *\n * This source file is free software, available under the following license:\n *   MIT license - http://datatables.net/license/mit\n *\n * This source file is distributed in the hope that it will be useful, but\n * WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY\n * or FITNESS FOR A PARTICULAR PURPOSE. See the license files for details.\n *\n * For details please refer to: http://www.datatables.net/extensions/select\n */\n(function( factory ){\n\tif ( true ) {\n\t\t// AMD\n\t\t!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(/*! jquery */ \"jquery\"), __webpack_require__(/*! datatables.net */ \"datatables.net\")], __WEBPACK_AMD_DEFINE_RESULT__ = (function ( $ ) {\n\t\t\treturn factory( $, window, document );\n\t\t}).apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),\n\t\t\t\t__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n\t}\n\telse {}\n}(function( $, window, document, undefined ) {\n'use strict';\nvar DataTable = $.fn.dataTable;\n\n\n// Version information for debugger\nDataTable.select = {};\n\nDataTable.select.version = '1.3.4-dev';\n\nDataTable.select.init = function ( dt ) {\n\tvar ctx = dt.settings()[0];\n\n\tif (ctx._select) {\n\t\treturn;\n\t}\n\n\tvar savedSelected = dt.state.loaded();\n\n\tvar selectAndSave = function(e, settings, data) {\n\t\tif(data === null || data.select === undefined) {\n\t\t\treturn;\n\t\t}\n\t\tdt.rows().deselect();\n\t\tdt.columns().deselect();\n\t\tdt.cells().deselect();\n\t\tif (data.select.rows !== undefined) {\n\t\t\tdt.rows(data.select.rows).select();\n\t\t}\n\t\tif (data.select.columns !== undefined) {\n\t\t\tdt.columns(data.select.columns).select();\n\t\t}\n\t\tif (data.select.cells !== undefined) {\n\t\t\tfor(var i = 0; i < data.select.cells.length; i++) {\n\t\t\t\tdt.cell(data.select.cells[i].row, data.select.cells[i].column).select();\n\t\t\t}\n\t\t}\n\t\tdt.state.save();\n\t}\n\t\n\tdt.one('init', function() {\n\t\tdt.on('stateSaveParams', function(e, settings, data) {\n\t\t\tdata.select = {};\n\t\t\tdata.select.rows = dt.rows({selected:true}).ids(true).toArray();\n\t\t\tdata.select.columns = dt.columns({selected:true})[0];\n\t\t\tdata.select.cells = dt.cells({selected:true})[0].map(function(coords) {\n\t\t\t\treturn {row: dt.row(coords.row).id(true), column: coords.column}\n\t\t\t});\n\t\t})\n\t\t\n\t\tselectAndSave(undefined, undefined, savedSelected)\n\t\tdt.on('stateLoaded stateLoadParams', selectAndSave)\n\t})\n\n\tvar init = ctx.oInit.select;\n\tvar defaults = DataTable.defaults.select;\n\tvar opts = init === undefined ?\n\t\tdefaults :\n\t\tinit;\n\n\t// Set defaults\n\tvar items = 'row';\n\tvar style = 'api';\n\tvar blurable = false;\n\tvar toggleable = true;\n\tvar info = true;\n\tvar selector = 'td, th';\n\tvar className = 'selected';\n\tvar setStyle = false;\n\n\tctx._select = {};\n\n\t// Initialisation customisations\n\tif ( opts === true ) {\n\t\tstyle = 'os';\n\t\tsetStyle = true;\n\t}\n\telse if ( typeof opts === 'string' ) {\n\t\tstyle = opts;\n\t\tsetStyle = true;\n\t}\n\telse if ( $.isPlainObject( opts ) ) {\n\t\tif ( opts.blurable !== undefined ) {\n\t\t\tblurable = opts.blurable;\n\t\t}\n\t\t\n\t\tif ( opts.toggleable !== undefined ) {\n\t\t\ttoggleable = opts.toggleable;\n\t\t}\n\n\t\tif ( opts.info !== undefined ) {\n\t\t\tinfo = opts.info;\n\t\t}\n\n\t\tif ( opts.items !== undefined ) {\n\t\t\titems = opts.items;\n\t\t}\n\n\t\tif ( opts.style !== undefined ) {\n\t\t\tstyle = opts.style;\n\t\t\tsetStyle = true;\n\t\t}\n\t\telse {\n\t\t\tstyle = 'os';\n\t\t\tsetStyle = true;\n\t\t}\n\n\t\tif ( opts.selector !== undefined ) {\n\t\t\tselector = opts.selector;\n\t\t}\n\n\t\tif ( opts.className !== undefined ) {\n\t\t\tclassName = opts.className;\n\t\t}\n\t}\n\n\tdt.select.selector( selector );\n\tdt.select.items( items );\n\tdt.select.style( style );\n\tdt.select.blurable( blurable );\n\tdt.select.toggleable( toggleable );\n\tdt.select.info( info );\n\tctx._select.className = className;\n\n\n\t// Sort table based on selected rows. Requires Select Datatables extension\n\t$.fn.dataTable.ext.order['select-checkbox'] = function ( settings, col ) {\n\t\treturn this.api().column( col, {order: 'index'} ).nodes().map( function ( td ) {\n\t\t\tif ( settings._select.items === 'row' ) {\n\t\t\t\treturn $( td ).parent().hasClass( settings._select.className );\n\t\t\t} else if ( settings._select.items === 'cell' ) {\n\t\t\t\treturn $( td ).hasClass( settings._select.className );\n\t\t\t}\n\t\t\treturn false;\n\t\t});\n\t};\n\n\t// If the init options haven't enabled select, but there is a selectable\n\t// class name, then enable\n\tif ( ! setStyle && $( dt.table().node() ).hasClass( 'selectable' ) ) {\n\t\tdt.select.style( 'os' );\n\t}\n};\n\n/*\n\nSelect is a collection of API methods, event handlers, event emitters and\nbuttons (for the `Buttons` extension) for DataTables. It provides the following\nfeatures, with an overview of how they are implemented:\n\n## Selection of rows, columns and cells. Whether an item is selected or not is\n   stored in:\n\n* rows: a `_select_selected` property which contains a boolean value of the\n  DataTables' `aoData` object for each row\n* columns: a `_select_selected` property which contains a boolean value of the\n  DataTables' `aoColumns` object for each column\n* cells: a `_selected_cells` property which contains an array of boolean values\n  of the `aoData` object for each row. The array is the same length as the\n  columns array, with each element of it representing a cell.\n\nThis method of using boolean flags allows Select to operate when nodes have not\nbeen created for rows / cells (DataTables' defer rendering feature).\n\n## API methods\n\nA range of API methods are available for triggering selection and de-selection\nof rows. Methods are also available to configure the selection events that can\nbe triggered by an end user (such as which items are to be selected). To a large\nextent, these of API methods *is* Select. It is basically a collection of helper\nfunctions that can be used to select items in a DataTable.\n\nConfiguration of select is held in the object `_select` which is attached to the\nDataTables settings object on initialisation. Select being available on a table\nis not optional when Select is loaded, but its default is for selection only to\nbe available via the API - so the end user wouldn't be able to select rows\nwithout additional configuration.\n\nThe `_select` object contains the following properties:\n\n```\n{\n\titems:string       - Can be `rows`, `columns` or `cells`. Defines what item \n\t                     will be selected if the user is allowed to activate row\n\t                     selection using the mouse.\n\tstyle:string       - Can be `none`, `single`, `multi` or `os`. Defines the\n\t                     interaction style when selecting items\n\tblurable:boolean   - If row selection can be cleared by clicking outside of\n\t                     the table\n\ttoggleable:boolean - If row selection can be cancelled by repeated clicking\n\t                     on the row\n\tinfo:boolean       - If the selection summary should be shown in the table\n\t                     information elements\n}\n```\n\nIn addition to the API methods, Select also extends the DataTables selector\noptions for rows, columns and cells adding a `selected` option to the selector\noptions object, allowing the developer to select only selected items or\nunselected items.\n\n## Mouse selection of items\n\nClicking on items can be used to select items. This is done by a simple event\nhandler that will select the items using the API methods.\n\n */\n\n\n/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n * Local functions\n */\n\n/**\n * Add one or more cells to the selection when shift clicking in OS selection\n * style cell selection.\n *\n * Cell range is more complicated than row and column as we want to select\n * in the visible grid rather than by index in sequence. For example, if you\n * click first in cell 1-1 and then shift click in 2-2 - cells 1-2 and 2-1\n * should also be selected (and not 1-3, 1-4. etc)\n * \n * @param  {DataTable.Api} dt   DataTable\n * @param  {object}        idx  Cell index to select to\n * @param  {object}        last Cell index to select from\n * @private\n */\nfunction cellRange( dt, idx, last )\n{\n\tvar indexes;\n\tvar columnIndexes;\n\tvar rowIndexes;\n\tvar selectColumns = function ( start, end ) {\n\t\tif ( start > end ) {\n\t\t\tvar tmp = end;\n\t\t\tend = start;\n\t\t\tstart = tmp;\n\t\t}\n\t\t\n\t\tvar record = false;\n\t\treturn dt.columns( ':visible' ).indexes().filter( function (i) {\n\t\t\tif ( i === start ) {\n\t\t\t\trecord = true;\n\t\t\t}\n\t\t\t\n\t\t\tif ( i === end ) { // not else if, as start might === end\n\t\t\t\trecord = false;\n\t\t\t\treturn true;\n\t\t\t}\n\n\t\t\treturn record;\n\t\t} );\n\t};\n\n\tvar selectRows = function ( start, end ) {\n\t\tvar indexes = dt.rows( { search: 'applied' } ).indexes();\n\n\t\t// Which comes first - might need to swap\n\t\tif ( indexes.indexOf( start ) > indexes.indexOf( end ) ) {\n\t\t\tvar tmp = end;\n\t\t\tend = start;\n\t\t\tstart = tmp;\n\t\t}\n\n\t\tvar record = false;\n\t\treturn indexes.filter( function (i) {\n\t\t\tif ( i === start ) {\n\t\t\t\trecord = true;\n\t\t\t}\n\t\t\t\n\t\t\tif ( i === end ) {\n\t\t\t\trecord = false;\n\t\t\t\treturn true;\n\t\t\t}\n\n\t\t\treturn record;\n\t\t} );\n\t};\n\n\tif ( ! dt.cells( { selected: true } ).any() && ! last ) {\n\t\t// select from the top left cell to this one\n\t\tcolumnIndexes = selectColumns( 0, idx.column );\n\t\trowIndexes = selectRows( 0 , idx.row );\n\t}\n\telse {\n\t\t// Get column indexes between old and new\n\t\tcolumnIndexes = selectColumns( last.column, idx.column );\n\t\trowIndexes = selectRows( last.row , idx.row );\n\t}\n\n\tindexes = dt.cells( rowIndexes, columnIndexes ).flatten();\n\n\tif ( ! dt.cells( idx, { selected: true } ).any() ) {\n\t\t// Select range\n\t\tdt.cells( indexes ).select();\n\t}\n\telse {\n\t\t// Deselect range\n\t\tdt.cells( indexes ).deselect();\n\t}\n}\n\n/**\n * Disable mouse selection by removing the selectors\n *\n * @param {DataTable.Api} dt DataTable to remove events from\n * @private\n */\nfunction disableMouseSelection( dt )\n{\n\tvar ctx = dt.settings()[0];\n\tvar selector = ctx._select.selector;\n\n\t$( dt.table().container() )\n\t\t.off( 'mousedown.dtSelect', selector )\n\t\t.off( 'mouseup.dtSelect', selector )\n\t\t.off( 'click.dtSelect', selector );\n\n\t$('body').off( 'click.dtSelect' + _safeId(dt.table().node()) );\n}\n\n/**\n * Attach mouse listeners to the table to allow mouse selection of items\n *\n * @param {DataTable.Api} dt DataTable to remove events from\n * @private\n */\nfunction enableMouseSelection ( dt )\n{\n\tvar container = $( dt.table().container() );\n\tvar ctx = dt.settings()[0];\n\tvar selector = ctx._select.selector;\n\tvar matchSelection;\n\n\tcontainer\n\t\t.on( 'mousedown.dtSelect', selector, function(e) {\n\t\t\t// Disallow text selection for shift clicking on the table so multi\n\t\t\t// element selection doesn't look terrible!\n\t\t\tif ( e.shiftKey || e.metaKey || e.ctrlKey ) {\n\t\t\t\tcontainer\n\t\t\t\t\t.css( '-moz-user-select', 'none' )\n\t\t\t\t\t.one('selectstart.dtSelect', selector, function () {\n\t\t\t\t\t\treturn false;\n\t\t\t\t\t} );\n\t\t\t}\n\n\t\t\tif ( window.getSelection ) {\n\t\t\t\tmatchSelection = window.getSelection();\n\t\t\t}\n\t\t} )\n\t\t.on( 'mouseup.dtSelect', selector, function() {\n\t\t\t// Allow text selection to occur again, Mozilla style (tested in FF\n\t\t\t// 35.0.1 - still required)\n\t\t\tcontainer.css( '-moz-user-select', '' );\n\t\t} )\n\t\t.on( 'click.dtSelect', selector, function ( e ) {\n\t\t\tvar items = dt.select.items();\n\t\t\tvar idx;\n\n\t\t\t// If text was selected (click and drag), then we shouldn't change\n\t\t\t// the row's selected state\n\t\t\tif ( matchSelection ) {\n\t\t\t\tvar selection = window.getSelection();\n\n\t\t\t\t// If the element that contains the selection is not in the table, we can ignore it\n\t\t\t\t// This can happen if the developer selects text from the click event\n\t\t\t\tif ( ! selection.anchorNode || $(selection.anchorNode).closest('table')[0] === dt.table().node() ) {\n\t\t\t\t\tif ( selection !== matchSelection ) {\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tvar ctx = dt.settings()[0];\n\t\t\tvar wrapperClass = dt.settings()[0].oClasses.sWrapper.trim().replace(/ +/g, '.');\n\n\t\t\t// Ignore clicks inside a sub-table\n\t\t\tif ( $(e.target).closest('div.'+wrapperClass)[0] != dt.table().container() ) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tvar cell = dt.cell( $(e.target).closest('td, th') );\n\n\t\t\t// Check the cell actually belongs to the host DataTable (so child\n\t\t\t// rows, etc, are ignored)\n\t\t\tif ( ! cell.any() ) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tvar event = $.Event('user-select.dt');\n\t\t\teventTrigger( dt, event, [ items, cell, e ] );\n\n\t\t\tif ( event.isDefaultPrevented() ) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tvar cellIndex = cell.index();\n\t\t\tif ( items === 'row' ) {\n\t\t\t\tidx = cellIndex.row;\n\t\t\t\ttypeSelect( e, dt, ctx, 'row', idx );\n\t\t\t}\n\t\t\telse if ( items === 'column' ) {\n\t\t\t\tidx = cell.index().column;\n\t\t\t\ttypeSelect( e, dt, ctx, 'column', idx );\n\t\t\t}\n\t\t\telse if ( items === 'cell' ) {\n\t\t\t\tidx = cell.index();\n\t\t\t\ttypeSelect( e, dt, ctx, 'cell', idx );\n\t\t\t}\n\n\t\t\tctx._select_lastCell = cellIndex;\n\t\t} );\n\n\t// Blurable\n\t$('body').on( 'click.dtSelect' + _safeId(dt.table().node()), function ( e ) {\n\t\tif ( ctx._select.blurable ) {\n\t\t\t// If the click was inside the DataTables container, don't blur\n\t\t\tif ( $(e.target).parents().filter( dt.table().container() ).length ) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\t// Ignore elements which have been removed from the DOM (i.e. paging\n\t\t\t// buttons)\n\t\t\tif ( $(e.target).parents('html').length === 0 ) {\n\t\t\t \treturn;\n\t\t\t}\n\n\t\t\t// Don't blur in Editor form\n\t\t\tif ( $(e.target).parents('div.DTE').length ) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tclear( ctx, true );\n\t\t}\n\t} );\n}\n\n/**\n * Trigger an event on a DataTable\n *\n * @param {DataTable.Api} api      DataTable to trigger events on\n * @param  {boolean}      selected true if selected, false if deselected\n * @param  {string}       type     Item type acting on\n * @param  {boolean}      any      Require that there are values before\n *     triggering\n * @private\n */\nfunction eventTrigger ( api, type, args, any )\n{\n\tif ( any && ! api.flatten().length ) {\n\t\treturn;\n\t}\n\n\tif ( typeof type === 'string' ) {\n\t\ttype = type +'.dt';\n\t}\n\n\targs.unshift( api );\n\n\t$(api.table().node()).trigger( type, args );\n}\n\n/**\n * Update the information element of the DataTable showing information about the\n * items selected. This is done by adding tags to the existing text\n * \n * @param {DataTable.Api} api DataTable to update\n * @private\n */\nfunction info ( api )\n{\n\tvar ctx = api.settings()[0];\n\n\tif ( ! ctx._select.info || ! ctx.aanFeatures.i ) {\n\t\treturn;\n\t}\n\n\tif ( api.select.style() === 'api' ) {\n\t\treturn;\n\t}\n\n\tvar rows    = api.rows( { selected: true } ).flatten().length;\n\tvar columns = api.columns( { selected: true } ).flatten().length;\n\tvar cells   = api.cells( { selected: true } ).flatten().length;\n\n\tvar add = function ( el, name, num ) {\n\t\tel.append( $('<span class=\"select-item\"/>').append( api.i18n(\n\t\t\t'select.'+name+'s',\n\t\t\t{ _: '%d '+name+'s selected', 0: '', 1: '1 '+name+' selected' },\n\t\t\tnum\n\t\t) ) );\n\t};\n\n\t// Internal knowledge of DataTables to loop over all information elements\n\t$.each( ctx.aanFeatures.i, function ( i, el ) {\n\t\tel = $(el);\n\n\t\tvar output  = $('<span class=\"select-info\"/>');\n\t\tadd( output, 'row', rows );\n\t\tadd( output, 'column', columns );\n\t\tadd( output, 'cell', cells  );\n\n\t\tvar exisiting = el.children('span.select-info');\n\t\tif ( exisiting.length ) {\n\t\t\texisiting.remove();\n\t\t}\n\n\t\tif ( output.text() !== '' ) {\n\t\t\tel.append( output );\n\t\t}\n\t} );\n}\n\n/**\n * Initialisation of a new table. Attach event handlers and callbacks to allow\n * Select to operate correctly.\n *\n * This will occur _after_ the initial DataTables initialisation, although\n * before Ajax data is rendered, if there is ajax data\n *\n * @param  {DataTable.settings} ctx Settings object to operate on\n * @private\n */\nfunction init ( ctx ) {\n\tvar api = new DataTable.Api( ctx );\n\tctx._select_init = true;\n\n\t// Row callback so that classes can be added to rows and cells if the item\n\t// was selected before the element was created. This will happen with the\n\t// `deferRender` option enabled.\n\t// \n\t// This method of attaching to `aoRowCreatedCallback` is a hack until\n\t// DataTables has proper events for row manipulation If you are reviewing\n\t// this code to create your own plug-ins, please do not do this!\n\tctx.aoRowCreatedCallback.push( {\n\t\tfn: function ( row, data, index ) {\n\t\t\tvar i, ien;\n\t\t\tvar d = ctx.aoData[ index ];\n\n\t\t\t// Row\n\t\t\tif ( d._select_selected ) {\n\t\t\t\t$( row ).addClass( ctx._select.className );\n\t\t\t}\n\n\t\t\t// Cells and columns - if separated out, we would need to do two\n\t\t\t// loops, so it makes sense to combine them into a single one\n\t\t\tfor ( i=0, ien=ctx.aoColumns.length ; i<ien ; i++ ) {\n\t\t\t\tif ( ctx.aoColumns[i]._select_selected || (d._selected_cells && d._selected_cells[i]) ) {\n\t\t\t\t\t$(d.anCells[i]).addClass( ctx._select.className );\n\t\t\t\t}\n\t\t\t}\n\t\t},\n\t\tsName: 'select-deferRender'\n\t} );\n\n\t// On Ajax reload we want to reselect all rows which are currently selected,\n\t// if there is an rowId (i.e. a unique value to identify each row with)\n\tapi.on( 'preXhr.dt.dtSelect', function (e, settings) {\n\t\tif (settings !== api.settings()[0]) {\n\t\t\t// Not triggered by our DataTable!\n\t\t\treturn;\n\t\t}\n\n\t\t// note that column selection doesn't need to be cached and then\n\t\t// reselected, as they are already selected\n\t\tvar rows = api.rows( { selected: true } ).ids( true ).filter( function ( d ) {\n\t\t\treturn d !== undefined;\n\t\t} );\n\n\t\tvar cells = api.cells( { selected: true } ).eq(0).map( function ( cellIdx ) {\n\t\t\tvar id = api.row( cellIdx.row ).id( true );\n\t\t\treturn id ?\n\t\t\t\t{ row: id, column: cellIdx.column } :\n\t\t\t\tundefined;\n\t\t} ).filter( function ( d ) {\n\t\t\treturn d !== undefined;\n\t\t} );\n\n\t\t// On the next draw, reselect the currently selected items\n\t\tapi.one( 'draw.dt.dtSelect', function () {\n\t\t\tapi.rows( rows ).select();\n\n\t\t\t// `cells` is not a cell index selector, so it needs a loop\n\t\t\tif ( cells.any() ) {\n\t\t\t\tcells.each( function ( id ) {\n\t\t\t\t\tapi.cells( id.row, id.column ).select();\n\t\t\t\t} );\n\t\t\t}\n\t\t} );\n\t} );\n\n\t// Update the table information element with selected item summary\n\tapi.on( 'draw.dtSelect.dt select.dtSelect.dt deselect.dtSelect.dt info.dt', function () {\n\t\tinfo( api );\n\t\tapi.state.save();\n\t} );\n\n\t// Clean up and release\n\tapi.on( 'destroy.dtSelect', function () {\n\t\tapi.rows({selected: true}).deselect();\n\n\t\tdisableMouseSelection( api );\n\t\tapi.off( '.dtSelect' );\n\t\t$('body').off('.dtSelect' + _safeId(api.table().node()));\n\t} );\n}\n\n/**\n * Add one or more items (rows or columns) to the selection when shift clicking\n * in OS selection style\n *\n * @param  {DataTable.Api} dt   DataTable\n * @param  {string}        type Row or column range selector\n * @param  {object}        idx  Item index to select to\n * @param  {object}        last Item index to select from\n * @private\n */\nfunction rowColumnRange( dt, type, idx, last )\n{\n\t// Add a range of rows from the last selected row to this one\n\tvar indexes = dt[type+'s']( { search: 'applied' } ).indexes();\n\tvar idx1 = $.inArray( last, indexes );\n\tvar idx2 = $.inArray( idx, indexes );\n\n\tif ( ! dt[type+'s']( { selected: true } ).any() && idx1 === -1 ) {\n\t\t// select from top to here - slightly odd, but both Windows and Mac OS\n\t\t// do this\n\t\tindexes.splice( $.inArray( idx, indexes )+1, indexes.length );\n\t}\n\telse {\n\t\t// reverse so we can shift click 'up' as well as down\n\t\tif ( idx1 > idx2 ) {\n\t\t\tvar tmp = idx2;\n\t\t\tidx2 = idx1;\n\t\t\tidx1 = tmp;\n\t\t}\n\n\t\tindexes.splice( idx2+1, indexes.length );\n\t\tindexes.splice( 0, idx1 );\n\t}\n\n\tif ( ! dt[type]( idx, { selected: true } ).any() ) {\n\t\t// Select range\n\t\tdt[type+'s']( indexes ).select();\n\t}\n\telse {\n\t\t// Deselect range - need to keep the clicked on row selected\n\t\tindexes.splice( $.inArray( idx, indexes ), 1 );\n\t\tdt[type+'s']( indexes ).deselect();\n\t}\n}\n\n/**\n * Clear all selected items\n *\n * @param  {DataTable.settings} ctx Settings object of the host DataTable\n * @param  {boolean} [force=false] Force the de-selection to happen, regardless\n *     of selection style\n * @private\n */\nfunction clear( ctx, force )\n{\n\tif ( force || ctx._select.style === 'single' ) {\n\t\tvar api = new DataTable.Api( ctx );\n\t\t\n\t\tapi.rows( { selected: true } ).deselect();\n\t\tapi.columns( { selected: true } ).deselect();\n\t\tapi.cells( { selected: true } ).deselect();\n\t}\n}\n\n/**\n * Select items based on the current configuration for style and items.\n *\n * @param  {object}             e    Mouse event object\n * @param  {DataTables.Api}     dt   DataTable\n * @param  {DataTable.settings} ctx  Settings object of the host DataTable\n * @param  {string}             type Items to select\n * @param  {int|object}         idx  Index of the item to select\n * @private\n */\nfunction typeSelect ( e, dt, ctx, type, idx )\n{\n\tvar style = dt.select.style();\n\tvar toggleable = dt.select.toggleable();\n\tvar isSelected = dt[type]( idx, { selected: true } ).any();\n\t\n\tif ( isSelected && ! toggleable ) {\n\t\treturn;\n\t}\n\n\tif ( style === 'os' ) {\n\t\tif ( e.ctrlKey || e.metaKey ) {\n\t\t\t// Add or remove from the selection\n\t\t\tdt[type]( idx ).select( ! isSelected );\n\t\t}\n\t\telse if ( e.shiftKey ) {\n\t\t\tif ( type === 'cell' ) {\n\t\t\t\tcellRange( dt, idx, ctx._select_lastCell || null );\n\t\t\t}\n\t\t\telse {\n\t\t\t\trowColumnRange( dt, type, idx, ctx._select_lastCell ?\n\t\t\t\t\tctx._select_lastCell[type] :\n\t\t\t\t\tnull\n\t\t\t\t);\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\t// No cmd or shift click - deselect if selected, or select\n\t\t\t// this row only\n\t\t\tvar selected = dt[type+'s']( { selected: true } );\n\n\t\t\tif ( isSelected && selected.flatten().length === 1 ) {\n\t\t\t\tdt[type]( idx ).deselect();\n\t\t\t}\n\t\t\telse {\n\t\t\t\tselected.deselect();\n\t\t\t\tdt[type]( idx ).select();\n\t\t\t}\n\t\t}\n\t} else if ( style == 'multi+shift' ) {\n\t\tif ( e.shiftKey ) {\n\t\t\tif ( type === 'cell' ) {\n\t\t\t\tcellRange( dt, idx, ctx._select_lastCell || null );\n\t\t\t}\n\t\t\telse {\n\t\t\t\trowColumnRange( dt, type, idx, ctx._select_lastCell ?\n\t\t\t\t\tctx._select_lastCell[type] :\n\t\t\t\t\tnull\n\t\t\t\t);\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\tdt[ type ]( idx ).select( ! isSelected );\n\t\t}\n\t}\n\telse {\n\t\tdt[ type ]( idx ).select( ! isSelected );\n\t}\n}\n\nfunction _safeId( node ) {\n\treturn node.id.replace(/[^a-zA-Z0-9\\-\\_]/g, '-');\n}\n\n\n\n/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n * DataTables selectors\n */\n\n// row and column are basically identical just assigned to different properties\n// and checking a different array, so we can dynamically create the functions to\n// reduce the code size\n$.each( [\n\t{ type: 'row', prop: 'aoData' },\n\t{ type: 'column', prop: 'aoColumns' }\n], function ( i, o ) {\n\tDataTable.ext.selector[ o.type ].push( function ( settings, opts, indexes ) {\n\t\tvar selected = opts.selected;\n\t\tvar data;\n\t\tvar out = [];\n\n\t\tif ( selected !== true && selected !== false ) {\n\t\t\treturn indexes;\n\t\t}\n\n\t\tfor ( var i=0, ien=indexes.length ; i<ien ; i++ ) {\n\t\t\tdata = settings[ o.prop ][ indexes[i] ];\n\n\t\t\tif ( (selected === true && data._select_selected === true) ||\n\t\t\t     (selected === false && ! data._select_selected )\n\t\t\t) {\n\t\t\t\tout.push( indexes[i] );\n\t\t\t}\n\t\t}\n\n\t\treturn out;\n\t} );\n} );\n\nDataTable.ext.selector.cell.push( function ( settings, opts, cells ) {\n\tvar selected = opts.selected;\n\tvar rowData;\n\tvar out = [];\n\n\tif ( selected === undefined ) {\n\t\treturn cells;\n\t}\n\n\tfor ( var i=0, ien=cells.length ; i<ien ; i++ ) {\n\t\trowData = settings.aoData[ cells[i].row ];\n\n\t\tif ( (selected === true && rowData._selected_cells && rowData._selected_cells[ cells[i].column ] === true) ||\n\t\t     (selected === false && ( ! rowData._selected_cells || ! rowData._selected_cells[ cells[i].column ] ) )\n\t\t) {\n\t\t\tout.push( cells[i] );\n\t\t}\n\t}\n\n\treturn out;\n} );\n\n\n\n/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n * DataTables API\n *\n * For complete documentation, please refer to the docs/api directory or the\n * DataTables site\n */\n\n// Local variables to improve compression\nvar apiRegister = DataTable.Api.register;\nvar apiRegisterPlural = DataTable.Api.registerPlural;\n\napiRegister( 'select()', function () {\n\treturn this.iterator( 'table', function ( ctx ) {\n\t\tDataTable.select.init( new DataTable.Api( ctx ) );\n\t} );\n} );\n\napiRegister( 'select.blurable()', function ( flag ) {\n\tif ( flag === undefined ) {\n\t\treturn this.context[0]._select.blurable;\n\t}\n\n\treturn this.iterator( 'table', function ( ctx ) {\n\t\tctx._select.blurable = flag;\n\t} );\n} );\n\napiRegister( 'select.toggleable()', function ( flag ) {\n\tif ( flag === undefined ) {\n\t\treturn this.context[0]._select.toggleable;\n\t}\n\n\treturn this.iterator( 'table', function ( ctx ) {\n\t\tctx._select.toggleable = flag;\n\t} );\n} );\n\napiRegister( 'select.info()', function ( flag ) {\n\tif ( flag === undefined ) {\n\t\treturn this.context[0]._select.info;\n\t}\n\n\treturn this.iterator( 'table', function ( ctx ) {\n\t\tctx._select.info = flag;\n\t} );\n} );\n\napiRegister( 'select.items()', function ( items ) {\n\tif ( items === undefined ) {\n\t\treturn this.context[0]._select.items;\n\t}\n\n\treturn this.iterator( 'table', function ( ctx ) {\n\t\tctx._select.items = items;\n\n\t\teventTrigger( new DataTable.Api( ctx ), 'selectItems', [ items ] );\n\t} );\n} );\n\n// Takes effect from the _next_ selection. None disables future selection, but\n// does not clear the current selection. Use the `deselect` methods for that\napiRegister( 'select.style()', function ( style ) {\n\tif ( style === undefined ) {\n\t\treturn this.context[0]._select.style;\n\t}\n\n\treturn this.iterator( 'table', function ( ctx ) {\n\t\tif ( ! ctx._select ) {\n\t\t\tDataTable.select.init( new DataTable.Api(ctx) );\n\t\t}\n\n\t\tif ( ! ctx._select_init ) {\n\t\t\tinit(ctx);\n\t\t}\n\n\t\tctx._select.style = style;\n\n\t\t// Add / remove mouse event handlers. They aren't required when only\n\t\t// API selection is available\n\t\tvar dt = new DataTable.Api( ctx );\n\t\tdisableMouseSelection( dt );\n\t\t\n\t\tif ( style !== 'api' ) {\n\t\t\tenableMouseSelection( dt );\n\t\t}\n\n\t\teventTrigger( new DataTable.Api( ctx ), 'selectStyle', [ style ] );\n\t} );\n} );\n\napiRegister( 'select.selector()', function ( selector ) {\n\tif ( selector === undefined ) {\n\t\treturn this.context[0]._select.selector;\n\t}\n\n\treturn this.iterator( 'table', function ( ctx ) {\n\t\tdisableMouseSelection( new DataTable.Api( ctx ) );\n\n\t\tctx._select.selector = selector;\n\n\t\tif ( ctx._select.style !== 'api' ) {\n\t\t\tenableMouseSelection( new DataTable.Api( ctx ) );\n\t\t}\n\t} );\n} );\n\n\n\napiRegisterPlural( 'rows().select()', 'row().select()', function ( select ) {\n\tvar api = this;\n\n\tif ( select === false ) {\n\t\treturn this.deselect();\n\t}\n\n\tthis.iterator( 'row', function ( ctx, idx ) {\n\t\tclear( ctx );\n\n\t\tctx.aoData[ idx ]._select_selected = true;\n\t\t$( ctx.aoData[ idx ].nTr ).addClass( ctx._select.className );\n\t} );\n\n\tthis.iterator( 'table', function ( ctx, i ) {\n\t\teventTrigger( api, 'select', [ 'row', api[i] ], true );\n\t} );\n\n\treturn this;\n} );\n\napiRegisterPlural( 'columns().select()', 'column().select()', function ( select ) {\n\tvar api = this;\n\n\tif ( select === false ) {\n\t\treturn this.deselect();\n\t}\n\n\tthis.iterator( 'column', function ( ctx, idx ) {\n\t\tclear( ctx );\n\n\t\tctx.aoColumns[ idx ]._select_selected = true;\n\n\t\tvar column = new DataTable.Api( ctx ).column( idx );\n\n\t\t$( column.header() ).addClass( ctx._select.className );\n\t\t$( column.footer() ).addClass( ctx._select.className );\n\n\t\tcolumn.nodes().to$().addClass( ctx._select.className );\n\t} );\n\n\tthis.iterator( 'table', function ( ctx, i ) {\n\t\teventTrigger( api, 'select', [ 'column', api[i] ], true );\n\t} );\n\n\treturn this;\n} );\n\napiRegisterPlural( 'cells().select()', 'cell().select()', function ( select ) {\n\tvar api = this;\n\n\tif ( select === false ) {\n\t\treturn this.deselect();\n\t}\n\n\tthis.iterator( 'cell', function ( ctx, rowIdx, colIdx ) {\n\t\tclear( ctx );\n\n\t\tvar data = ctx.aoData[ rowIdx ];\n\n\t\tif ( data._selected_cells === undefined ) {\n\t\t\tdata._selected_cells = [];\n\t\t}\n\n\t\tdata._selected_cells[ colIdx ] = true;\n\n\t\tif ( data.anCells ) {\n\t\t\t$( data.anCells[ colIdx ] ).addClass( ctx._select.className );\n\t\t}\n\t} );\n\n\tthis.iterator( 'table', function ( ctx, i ) {\n\t\teventTrigger( api, 'select', [ 'cell', api.cells(api[i]).indexes().toArray() ], true );\n\t} );\n\n\treturn this;\n} );\n\n\napiRegisterPlural( 'rows().deselect()', 'row().deselect()', function () {\n\tvar api = this;\n\n\tthis.iterator( 'row', function ( ctx, idx ) {\n\t\tctx.aoData[ idx ]._select_selected = false;\n\t\tctx._select_lastCell = null;\n\t\t$( ctx.aoData[ idx ].nTr ).removeClass( ctx._select.className );\n\t} );\n\n\tthis.iterator( 'table', function ( ctx, i ) {\n\t\teventTrigger( api, 'deselect', [ 'row', api[i] ], true );\n\t} );\n\n\treturn this;\n} );\n\napiRegisterPlural( 'columns().deselect()', 'column().deselect()', function () {\n\tvar api = this;\n\n\tthis.iterator( 'column', function ( ctx, idx ) {\n\t\tctx.aoColumns[ idx ]._select_selected = false;\n\n\t\tvar api = new DataTable.Api( ctx );\n\t\tvar column = api.column( idx );\n\n\t\t$( column.header() ).removeClass( ctx._select.className );\n\t\t$( column.footer() ).removeClass( ctx._select.className );\n\n\t\t// Need to loop over each cell, rather than just using\n\t\t// `column().nodes()` as cells which are individually selected should\n\t\t// not have the `selected` class removed from them\n\t\tapi.cells( null, idx ).indexes().each( function (cellIdx) {\n\t\t\tvar data = ctx.aoData[ cellIdx.row ];\n\t\t\tvar cellSelected = data._selected_cells;\n\n\t\t\tif ( data.anCells && (! cellSelected || ! cellSelected[ cellIdx.column ]) ) {\n\t\t\t\t$( data.anCells[ cellIdx.column  ] ).removeClass( ctx._select.className );\n\t\t\t}\n\t\t} );\n\t} );\n\n\tthis.iterator( 'table', function ( ctx, i ) {\n\t\teventTrigger( api, 'deselect', [ 'column', api[i] ], true );\n\t} );\n\n\treturn this;\n} );\n\napiRegisterPlural( 'cells().deselect()', 'cell().deselect()', function () {\n\tvar api = this;\n\n\tthis.iterator( 'cell', function ( ctx, rowIdx, colIdx ) {\n\t\tvar data = ctx.aoData[ rowIdx ];\n\n\t\tif(data._selected_cells !== undefined) {\n\t\t\tdata._selected_cells[ colIdx ] = false;\n\t\t}\n\n\t\t// Remove class only if the cells exist, and the cell is not column\n\t\t// selected, in which case the class should remain (since it is selected\n\t\t// in the column)\n\t\tif ( data.anCells && ! ctx.aoColumns[ colIdx ]._select_selected ) {\n\t\t\t$( data.anCells[ colIdx ] ).removeClass( ctx._select.className );\n\t\t}\n\t} );\n\n\tthis.iterator( 'table', function ( ctx, i ) {\n\t\teventTrigger( api, 'deselect', [ 'cell', api[i] ], true );\n\t} );\n\n\treturn this;\n} );\n\n\n\n/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n * Buttons\n */\nfunction i18n( label, def ) {\n\treturn function (dt) {\n\t\treturn dt.i18n( 'buttons.'+label, def );\n\t};\n}\n\n// Common events with suitable namespaces\nfunction namespacedEvents ( config ) {\n\tvar unique = config._eventNamespace;\n\n\treturn 'draw.dt.DT'+unique+' select.dt.DT'+unique+' deselect.dt.DT'+unique;\n}\n\nfunction enabled ( dt, config ) {\n\tif ( $.inArray( 'rows', config.limitTo ) !== -1 && dt.rows( { selected: true } ).any() ) {\n\t\treturn true;\n\t}\n\n\tif ( $.inArray( 'columns', config.limitTo ) !== -1 && dt.columns( { selected: true } ).any() ) {\n\t\treturn true;\n\t}\n\n\tif ( $.inArray( 'cells', config.limitTo ) !== -1 && dt.cells( { selected: true } ).any() ) {\n\t\treturn true;\n\t}\n\n\treturn false;\n}\n\nvar _buttonNamespace = 0;\n\n$.extend( DataTable.ext.buttons, {\n\tselected: {\n\t\ttext: i18n( 'selected', 'Selected' ),\n\t\tclassName: 'buttons-selected',\n\t\tlimitTo: [ 'rows', 'columns', 'cells' ],\n\t\tinit: function ( dt, node, config ) {\n\t\t\tvar that = this;\n\t\t\tconfig._eventNamespace = '.select'+(_buttonNamespace++);\n\n\t\t\t// .DT namespace listeners are removed by DataTables automatically\n\t\t\t// on table destroy\n\t\t\tdt.on( namespacedEvents(config), function () {\n\t\t\t\tthat.enable( enabled(dt, config) );\n\t\t\t} );\n\n\t\t\tthis.disable();\n\t\t},\n\t\tdestroy: function ( dt, node, config ) {\n\t\t\tdt.off( config._eventNamespace );\n\t\t}\n\t},\n\tselectedSingle: {\n\t\ttext: i18n( 'selectedSingle', 'Selected single' ),\n\t\tclassName: 'buttons-selected-single',\n\t\tinit: function ( dt, node, config ) {\n\t\t\tvar that = this;\n\t\t\tconfig._eventNamespace = '.select'+(_buttonNamespace++);\n\n\t\t\tdt.on( namespacedEvents(config), function () {\n\t\t\t\tvar count = dt.rows( { selected: true } ).flatten().length +\n\t\t\t\t            dt.columns( { selected: true } ).flatten().length +\n\t\t\t\t            dt.cells( { selected: true } ).flatten().length;\n\n\t\t\t\tthat.enable( count === 1 );\n\t\t\t} );\n\n\t\t\tthis.disable();\n\t\t},\n\t\tdestroy: function ( dt, node, config ) {\n\t\t\tdt.off( config._eventNamespace );\n\t\t}\n\t},\n\tselectAll: {\n\t\ttext: i18n( 'selectAll', 'Select all' ),\n\t\tclassName: 'buttons-select-all',\n\t\taction: function () {\n\t\t\tvar items = this.select.items();\n\t\t\tthis[ items+'s' ]().select();\n\t\t}\n\t},\n\tselectNone: {\n\t\ttext: i18n( 'selectNone', 'Deselect all' ),\n\t\tclassName: 'buttons-select-none',\n\t\taction: function () {\n\t\t\tclear( this.settings()[0], true );\n\t\t},\n\t\tinit: function ( dt, node, config ) {\n\t\t\tvar that = this;\n\t\t\tconfig._eventNamespace = '.select'+(_buttonNamespace++);\n\n\t\t\tdt.on( namespacedEvents(config), function () {\n\t\t\t\tvar count = dt.rows( { selected: true } ).flatten().length +\n\t\t\t\t            dt.columns( { selected: true } ).flatten().length +\n\t\t\t\t            dt.cells( { selected: true } ).flatten().length;\n\n\t\t\t\tthat.enable( count > 0 );\n\t\t\t} );\n\n\t\t\tthis.disable();\n\t\t},\n\t\tdestroy: function ( dt, node, config ) {\n\t\t\tdt.off( config._eventNamespace );\n\t\t}\n\t}\n} );\n\n$.each( [ 'Row', 'Column', 'Cell' ], function ( i, item ) {\n\tvar lc = item.toLowerCase();\n\n\tDataTable.ext.buttons[ 'select'+item+'s' ] = {\n\t\ttext: i18n( 'select'+item+'s', 'Select '+lc+'s' ),\n\t\tclassName: 'buttons-select-'+lc+'s',\n\t\taction: function () {\n\t\t\tthis.select.items( lc );\n\t\t},\n\t\tinit: function ( dt ) {\n\t\t\tvar that = this;\n\n\t\t\tdt.on( 'selectItems.dt.DT', function ( e, ctx, items ) {\n\t\t\t\tthat.active( items === lc );\n\t\t\t} );\n\t\t}\n\t};\n} );\n\n\n\n/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n * Initialisation\n */\n\n// DataTables creation - check if select has been defined in the options. Note\n// this required that the table be in the document! If it isn't then something\n// needs to trigger this method unfortunately. The next major release of\n// DataTables will rework the events and address this.\n$(document).on( 'preInit.dt.dtSelect', function (e, ctx) {\n\tif ( e.namespace !== 'dt' ) {\n\t\treturn;\n\t}\n\n\tDataTable.select.init( new DataTable.Api( ctx ) );\n} );\n\n\nreturn DataTable.select;\n}));\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvZGF0YXRhYmxlcy5uZXQtc2VsZWN0L2pzL2RhdGFUYWJsZXMuc2VsZWN0LmpzPzI4YWQiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0I7QUFDeEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU0sSUFBMEM7QUFDaEQ7QUFDQSxFQUFFLGlDQUFRLENBQUMsMkNBQVEsRUFBRSwyREFBZ0IsQ0FBQyxtQ0FBRTtBQUN4QztBQUNBLEdBQUc7QUFBQSxvR0FBRTtBQUNMO0FBQ0EsTUFBTSxFQWlCSjtBQUNGLENBQUM7QUFDRDtBQUNBOzs7QUFHQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUIsOEJBQThCO0FBQy9DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsK0JBQStCLGNBQWM7QUFDN0MscUNBQXFDLGNBQWM7QUFDbkQsaUNBQWlDLGNBQWM7QUFDL0MsWUFBWTtBQUNaLElBQUk7QUFDSixHQUFHOztBQUVIO0FBQ0E7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFD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QUFDQTtBQUNBOztBQUVBLHFDQUFxQyxRQUFRO0FBQzdDOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEVBQUU7QUFDRixDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSxrQ0FBa0MsUUFBUTtBQUMxQzs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxDQUFDOzs7O0FBSUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxFQUFFO0FBQ0YsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsRUFBRTtBQUNGLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEVBQUU7QUFDRixDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxFQUFFO0FBQ0YsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0EsRUFBRTtBQUNGLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxFQUFFO0FBQ0YsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRixDQUFDOzs7O0FBSUQ7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBLENBQUM7O0FBRUQ7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBLENBQUM7O0FBRUQ7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBLENBQUM7OztBQUdEO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQSxFQUFFOztBQUVGO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0gsRUFBRTs7QUFFRjtBQUNBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBLENBQUM7O0FBRUQ7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQSxFQUFFOztBQUVGO0FBQ0EsQ0FBQzs7OztBQUlEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQSw4REFBOEQsaUJBQWlCO0FBQy9FO0FBQ0E7O0FBRUEsb0VBQW9FLGlCQUFpQjtBQUNyRjtBQUNBOztBQUVBLGdFQUFnRSxpQkFBaUI7QUFDakY7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJOztBQUVKO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSwwQkFBMEIsaUJBQWlCO0FBQzNDLDZCQUE2QixpQkFBaUI7QUFDOUMsMkJBQTJCLGlCQUFpQjs7QUFFNUM7QUFDQSxJQUFJOztBQUVKO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLDBCQUEwQixpQkFBaUI7QUFDM0MsNkJBQTZCLGlCQUFpQjtBQUM5QywyQkFBMkIsaUJBQWlCOztBQUU1QztBQUNBLElBQUk7O0FBRUo7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBOztBQUVBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBLENBQUM7Ozs7QUFJRDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLENBQUM7OztBQUdEO0FBQ0EsQ0FBQyIsImZpbGUiOiIuL25vZGVfbW9kdWxlcy9kYXRhdGFibGVzLm5ldC1zZWxlY3QvanMvZGF0YVRhYmxlcy5zZWxlY3QuanMuanMiLCJzb3VyY2VzQ29udGVudCI6WyIvKiEgU2VsZWN0IGZvciBEYXRhVGFibGVzIDEuMy40LWRldlxuICogMjAxNS0yMDIxIFNwcnlNZWRpYSBMdGQgLSBkYXRhdGFibGVzLm5ldC9saWNlbnNlL21pdFxuICovXG5cbi8qKlxuICogQHN1bW1hcnkgICAgIFNlbGVjdCBmb3IgRGF0YVRhYmxlc1xuICogQGRlc2NyaXB0aW9uIEEgY29sbGVjdGlvbiBvZiBBUEkgbWV0aG9kcywgZXZlbnRzIGFuZCBidXR0b25zIGZvciBEYXRhVGFibGVzXG4gKiAgIHRoYXQgcHJvdmlkZXMgc2VsZWN0aW9uIG9wdGlvbnMgb2YgdGhlIGl0ZW1zIGluIGEgRGF0YVRhYmxlXG4gKiBAdmVyc2lvbiAgICAgMS4zLjQtZGV2XG4gKiBAZmlsZSAgICAgICAgZGF0YVRhYmxlcy5zZWxlY3QuanNcbiAqIEBhdXRob3IgICAgICBTcHJ5TWVkaWEgTHRkICh3d3cuc3ByeW1lZGlhLmNvLnVrKVxuICogQGNvbnRhY3QgICAgIGRhdGF0YWJsZXMubmV0L2ZvcnVtc1xuICogQGNvcHlyaWdodCAgIENvcHlyaWdodCAyMDE1LTIwMjEgU3ByeU1lZGlhIEx0ZC5cbiAqXG4gKiBUaGlzIHNvdXJjZSBmaWxlIGlzIGZyZWUgc29mdHdhcmUsIGF2YWlsYWJsZSB1bmRlciB0aGUgZm9sbG93aW5nIGxpY2Vuc2U6XG4gKiAgIE1JVCBsaWNlbnNlIC0gaHR0cDovL2RhdGF0YWJsZXMubmV0L2xpY2Vuc2UvbWl0XG4gKlxuICogVGhpcyBzb3VyY2UgZmlsZSBpcyBkaXN0cmlidXRlZCBpbiB0aGUgaG9wZSB0aGF0IGl0IHdpbGwgYmUgdXNlZnVsLCBidXRcbiAqIFdJVEhPVVQgQU5ZIFdBUlJBTlRZOyB3aXRob3V0IGV2ZW4gdGhlIGltcGxpZWQgd2FycmFudHkgb2YgTUVSQ0hBTlRBQklMSVRZXG4gKiBvciBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRS4gU2VlIHRoZSBsaWNlbnNlIGZpbGVzIGZvciBkZXRhaWxzLlxuICpcbiAqIEZvciBkZXRhaWxzIHBsZWFzZSByZWZlciB0bzogaHR0cDovL3d3dy5kYXRhdGFibGVzLm5ldC9leHRlbnNpb25zL3NlbGVjdFxuICovXG4oZnVuY3Rpb24oIGZhY3RvcnkgKXtcblx0aWYgKCB0eXBlb2YgZGVmaW5lID09PSAnZnVuY3Rpb24nICYmIGRlZmluZS5hbWQgKSB7XG5cdFx0Ly8gQU1EXG5cdFx0ZGVmaW5lKCBbJ2pxdWVyeScsICdkYXRhdGFibGVzLm5ldCddLCBmdW5jdGlvbiAoICQgKSB7XG5cdFx0XHRyZXR1cm4gZmFjdG9yeSggJCwgd2luZG93LCBkb2N1bWVudCApO1xuXHRcdH0gKTtcblx0fVxuXHRlbHNlIGlmICggdHlwZW9mIGV4cG9ydHMgPT09ICdvYmplY3QnICkge1xuXHRcdC8vIENvbW1vbkpTXG5cdFx0bW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAocm9vdCwgJCkge1xuXHRcdFx0aWYgKCAhIHJvb3QgKSB7XG5cdFx0XHRcdHJvb3QgPSB3aW5kb3c7XG5cdFx0XHR9XG5cblx0XHRcdGlmICggISAkIHx8ICEgJC5mbi5kYXRhVGFibGUgKSB7XG5cdFx0XHRcdCQgPSByZXF1aXJlKCdkYXRhdGFibGVzLm5ldCcpKHJvb3QsICQpLiQ7XG5cdFx0XHR9XG5cblx0XHRcdHJldHVybiBmYWN0b3J5KCAkLCByb290LCByb290LmRvY3VtZW50ICk7XG5cdFx0fTtcblx0fVxuXHRlbHNlIHtcblx0XHQvLyBCcm93c2VyXG5cdFx0ZmFjdG9yeSggalF1ZXJ5LCB3aW5kb3csIGRvY3VtZW50ICk7XG5cdH1cbn0oZnVuY3Rpb24oICQsIHdpbmRvdywgZG9jdW1lbnQsIHVuZGVmaW5lZCApIHtcbid1c2Ugc3RyaWN0JztcbnZhciBEYXRhVGFibGUgPSAkLmZuLmRhdGFUYWJsZTtcblxuXG4vLyBWZXJzaW9uIGluZm9ybWF0aW9uIGZvciBkZWJ1Z2dlclxuRGF0YVRhYmxlLnNlbGVjdCA9IHt9O1xuXG5EYXRhVGFibGUuc2VsZWN0LnZlcnNpb24gPSAnMS4zLjQtZGV2JztcblxuRGF0YVRhYmxlLnNlbGVjdC5pbml0ID0gZnVuY3Rpb24gKCBkdCApIHtcblx0dmFyIGN0eCA9IGR0LnNldHRpbmdzKClbMF07XG5cblx0aWYgKGN0eC5fc2VsZWN0KSB7XG5cdFx0cmV0dXJuO1xuXHR9XG5cblx0dmFyIHNhdmVkU2VsZWN0ZWQgPSBkdC5zdGF0ZS5sb2FkZWQoKTtcblxuXHR2YXIgc2VsZWN0QW5kU2F2ZSA9IGZ1bmN0aW9uKGUsIHNldHRpbmdzLCBkYXRhKSB7XG5cdFx0aWYoZGF0YSA9PT0gbnVsbCB8fCBkYXRhLnNlbGVjdCA9PT0gdW5kZWZpbmVkKSB7XG5cdFx0XHRyZXR1cm47XG5cdFx0fVxuXHRcdGR0LnJvd3MoKS5kZXNlbGVjdCgpO1xuXHRcdGR0LmNvbHVtbnMoKS5kZXNlbGVjdCgpO1xuXHRcdGR0LmNlbGxzKCkuZGVzZWxlY3QoKTtcblx0XHRpZiAoZGF0YS5zZWxlY3Qucm93cyAhPT0gdW5kZWZpbmVkKSB7XG5cdFx0XHRkdC5yb3dzKGRhdGEuc2VsZWN0LnJvd3MpLnNlbGVjdCgpO1xuXHRcdH1cblx0XHRpZiAoZGF0YS5zZWxlY3QuY29sdW1ucyAhPT0gdW5kZWZpbmVkKSB7XG5cdFx0XHRkdC5jb2x1bW5zKGRhdGEuc2VsZWN0LmNvbHVtbnMpLnNlbGVjdCgpO1xuXHRcdH1cblx0XHRpZiAoZGF0YS5zZWxlY3QuY2VsbHMgIT09IHVuZGVmaW5lZCkge1xuXHRcdFx0Zm9yKHZhciBpID0gMDsgaSA8IGRhdGEuc2VsZWN0LmNlbGxzLmxlbmd0aDsgaSsrKSB7XG5cdFx0XHRcdGR0LmNlbGwoZGF0YS5zZWxlY3QuY2VsbHNbaV0ucm93LCBkYXRhLnNlbGVjdC5jZWxsc1tpXS5jb2x1bW4pLnNlbGVjdCgpO1xuXHRcdFx0fVxuXHRcdH1cblx0XHRkdC5zdGF0ZS5zYXZlKCk7XG5cdH1cblx0XG5cdGR0Lm9uZSgnaW5pdCcsIGZ1bmN0aW9uKCkge1xuXHRcdGR0Lm9uKCdzdGF0ZVNhdmVQYXJhbXMnLCBmdW5jdGlvbihlLCBzZXR0aW5ncywgZGF0YSkge1xuXHRcdFx0ZGF0YS5zZWxlY3QgPSB7fTtcblx0XHRcdGRhdGEuc2VsZWN0LnJvd3MgPSBkdC5yb3dzKHtzZWxlY3RlZDp0cnVlfSkuaWRzKHRydWUpLnRvQXJyYXkoKTtcblx0XHRcdGRhdGEuc2VsZWN0LmNvbHVtbnMgPSBkdC5jb2x1bW5zKHtzZWxlY3RlZDp0cnVlfSlbMF07XG5cdFx0XHRkYXRhLnNlbGVjdC5jZWxscyA9IGR0LmNlbGxzKHtzZWxlY3RlZDp0cnVlfSlbMF0ubWFwKGZ1bmN0aW9uKGNvb3Jkcykge1xuXHRcdFx0XHRyZXR1cm4ge3JvdzogZHQucm93KGNvb3Jkcy5yb3cpLmlkKHRydWUpLCBjb2x1bW46IGNvb3Jkcy5jb2x1bW59XG5cdFx0XHR9KTtcblx0XHR9KVxuXHRcdFxuXHRcdHNlbGVjdEFuZFNhdmUodW5kZWZpbmVkLCB1bmRlZmluZWQsIHNhdmVkU2VsZWN0ZWQpXG5cdFx0ZHQub24oJ3N0YXRlTG9hZGVkIHN0YXRlTG9hZFBhcmFtcycsIHNlbGVjdEFuZFNhdmUpXG5cdH0pXG5cblx0dmFyIGluaXQgPSBjdHgub0luaXQuc2VsZWN0O1xuXHR2YXIgZGVmYXVsdHMgPSBEYXRhVGFibGUuZGVmYXVsdHMuc2VsZWN0O1xuXHR2YXIgb3B0cyA9IGluaXQgPT09IHVuZGVmaW5lZCA/XG5cdFx0ZGVmYXVsdHMgOlxuXHRcdGluaXQ7XG5cblx0Ly8gU2V0IGRlZmF1bHRzXG5cdHZhciBpdGVtcyA9ICdyb3cnO1xuXHR2YXIgc3R5bGUgPSAnYXBpJztcblx0dmFyIGJsdXJhYmxlID0gZmFsc2U7XG5cdHZhciB0b2dnbGVhYmxlID0gdHJ1ZTtcblx0dmFyIGluZm8gPSB0cnVlO1xuXHR2YXIgc2VsZWN0b3IgPSAndGQsIHRoJztcblx0dmFyIGNsYXNzTmFtZSA9ICdzZWxlY3RlZCc7XG5cdHZhciBzZXRTdHlsZSA9IGZhbHNlO1xuXG5cdGN0eC5fc2VsZWN0ID0ge307XG5cblx0Ly8gSW5pdGlhbGlzYXRpb24gY3VzdG9taXNhdGlvbnNcblx0aWYgKCBvcHRzID09PSB0cnVlICkge1xuXHRcdHN0eWxlID0gJ29zJztcblx0XHRzZXRTdHlsZSA9IHRydWU7XG5cdH1cblx0ZWxzZSBpZiAoIHR5cGVvZiBvcHRzID09PSAnc3RyaW5nJyApIHtcblx0XHRzdHlsZSA9IG9wdHM7XG5cdFx0c2V0U3R5bGUgPSB0cnVlO1xuXHR9XG5cdGVsc2UgaWYgKCAkLmlzUGxhaW5PYmplY3QoIG9wdHMgKSApIHtcblx0XHRpZiAoIG9wdHMuYmx1cmFibGUgIT09IHVuZGVmaW5lZCApIHtcblx0XHRcdGJsdXJhYmxlID0gb3B0cy5ibHVyYWJsZTtcblx0XHR9XG5cdFx0XG5cdFx0aWYgKCBvcHRzLnRvZ2dsZWFibGUgIT09IHVuZGVmaW5lZCApIHtcblx0XHRcdHRvZ2dsZWFibGUgPSBvcHRzLnRvZ2dsZWFibGU7XG5cdFx0fVxuXG5cdFx0aWYgKCBvcHRzLmluZm8gIT09IHVuZGVmaW5lZCApIHtcblx0XHRcdGluZm8gPSBvcHRzLmluZm87XG5cdFx0fVxuXG5cdFx0aWYgKCBvcHRzLml0ZW1zICE9PSB1bmRlZmluZWQgKSB7XG5cdFx0XHRpdGVtcyA9IG9wdHMuaXRlbXM7XG5cdFx0fVxuXG5cdFx0aWYgKCBvcHRzLnN0eWxlICE9PSB1bmRlZmluZWQgKSB7XG5cdFx0XHRzdHlsZSA9IG9wdHMuc3R5bGU7XG5cdFx0XHRzZXRTdHlsZSA9IHRydWU7XG5cdFx0fVxuXHRcdGVsc2Uge1xuXHRcdFx0c3R5bGUgPSAnb3MnO1xuXHRcdFx0c2V0U3R5bGUgPSB0cnVlO1xuXHRcdH1cblxuXHRcdGlmICggb3B0cy5zZWxlY3RvciAhPT0gdW5kZWZpbmVkICkge1xuXHRcdFx0c2VsZWN0b3IgPSBvcHRzLnNlbGVjdG9yO1xuXHRcdH1cblxuXHRcdGlmICggb3B0cy5jbGFzc05hbWUgIT09IHVuZGVmaW5lZCApIHtcblx0XHRcdGNsYXNzTmFtZSA9IG9wdHMuY2xhc3NOYW1lO1xuXHRcdH1cblx0fVxuXG5cdGR0LnNlbGVjdC5zZWxlY3Rvciggc2VsZWN0b3IgKTtcblx0ZHQuc2VsZWN0Lml0ZW1zKCBpdGVtcyApO1xuXHRkdC5zZWxlY3Quc3R5bGUoIHN0eWxlICk7XG5cdGR0LnNlbGVjdC5ibHVyYWJsZSggYmx1cmFibGUgKTtcblx0ZHQuc2VsZWN0LnRvZ2dsZWFibGUoIHRvZ2dsZWFibGUgKTtcblx0ZHQuc2VsZWN0LmluZm8oIGluZm8gKTtcblx0Y3R4Ll9zZWxlY3QuY2xhc3NOYW1lID0gY2xhc3NOYW1lO1xuXG5cblx0Ly8gU29ydCB0YWJsZSBiYXNlZCBvbiBzZWxlY3RlZCByb3dzLiBSZXF1aXJlcyBTZWxlY3QgRGF0YXRhYmxlcyBleHRlbnNpb25cblx0JC5mbi5kYXRhVGFibGUuZXh0Lm9yZGVyWydzZWxlY3QtY2hlY2tib3gnXSA9IGZ1bmN0aW9uICggc2V0dGluZ3MsIGNvbCApIHtcblx0XHRyZXR1cm4gdGhpcy5hcGkoKS5jb2x1bW4oIGNvbCwge29yZGVyOiAnaW5kZXgnfSApLm5vZGVzKCkubWFwKCBmdW5jdGlvbiAoIHRkICkge1xuXHRcdFx0aWYgKCBzZXR0aW5ncy5fc2VsZWN0Lml0ZW1zID09PSAncm93JyApIHtcblx0XHRcdFx0cmV0dXJuICQoIHRkICkucGFyZW50KCkuaGFzQ2xhc3MoIHNldHRpbmdzLl9zZWxlY3QuY2xhc3NOYW1lICk7XG5cdFx0XHR9IGVsc2UgaWYgKCBzZXR0aW5ncy5fc2VsZWN0Lml0ZW1zID09PSAnY2VsbCcgKSB7XG5cdFx0XHRcdHJldHVybiAkKCB0ZCApLmhhc0NsYXNzKCBzZXR0aW5ncy5fc2VsZWN0LmNsYXNzTmFtZSApO1xuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdH0pO1xuXHR9O1xuXG5cdC8vIElmIHRoZSBpbml0IG9wdGlvbnMgaGF2ZW4ndCBlbmFibGVkIHNlbGVjdCwgYnV0IHRoZXJlIGlzIGEgc2VsZWN0YWJsZVxuXHQvLyBjbGFzcyBuYW1lLCB0aGVuIGVuYWJsZVxuXHRpZiAoICEgc2V0U3R5bGUgJiYgJCggZHQudGFibGUoKS5ub2RlKCkgKS5oYXNDbGFzcyggJ3NlbGVjdGFibGUnICkgKSB7XG5cdFx0ZHQuc2VsZWN0LnN0eWxlKCAnb3MnICk7XG5cdH1cbn07XG5cbi8qXG5cblNlbGVjdCBpcyBhIGNvbGxlY3Rpb24gb2YgQVBJIG1ldGhvZHMsIGV2ZW50IGhhbmRsZXJzLCBldmVudCBlbWl0dGVycyBhbmRcbmJ1dHRvbnMgKGZvciB0aGUgYEJ1dHRvbnNgIGV4dGVuc2lvbikgZm9yIERhdGFUYWJsZXMuIEl0IHByb3ZpZGVzIHRoZSBmb2xsb3dpbmdcbmZlYXR1cmVzLCB3aXRoIGFuIG92ZXJ2aWV3IG9mIGhvdyB0aGV5IGFyZSBpbXBsZW1lbnRlZDpcblxuIyMgU2VsZWN0aW9uIG9mIHJvd3MsIGNvbHVtbnMgYW5kIGNlbGxzLiBXaGV0aGVyIGFuIGl0ZW0gaXMgc2VsZWN0ZWQgb3Igbm90IGlzXG4gICBzdG9yZWQgaW46XG5cbiogcm93czogYSBgX3NlbGVjdF9zZWxlY3RlZGAgcHJvcGVydHkgd2hpY2ggY29udGFpbnMgYSBib29sZWFuIHZhbHVlIG9mIHRoZVxuICBEYXRhVGFibGVzJyBgYW9EYXRhYCBvYmplY3QgZm9yIGVhY2ggcm93XG4qIGNvbHVtbnM6IGEgYF9zZWxlY3Rfc2VsZWN0ZWRgIHByb3BlcnR5IHdoaWNoIGNvbnRhaW5zIGEgYm9vbGVhbiB2YWx1ZSBvZiB0aGVcbiAgRGF0YVRhYmxlcycgYGFvQ29sdW1uc2Agb2JqZWN0IGZvciBlYWNoIGNvbHVtblxuKiBjZWxsczogYSBgX3NlbGVjdGVkX2NlbGxzYCBwcm9wZXJ0eSB3aGljaCBjb250YWlucyBhbiBhcnJheSBvZiBib29sZWFuIHZhbHVlc1xuICBvZiB0aGUgYGFvRGF0YWAgb2JqZWN0IGZvciBlYWNoIHJvdy4gVGhlIGFycmF5IGlzIHRoZSBzYW1lIGxlbmd0aCBhcyB0aGVcbiAgY29sdW1ucyBhcnJheSwgd2l0aCBlYWNoIGVsZW1lbnQgb2YgaXQgcmVwcmVzZW50aW5nIGEgY2VsbC5cblxuVGhpcyBtZXRob2Qgb2YgdXNpbmcgYm9vbGVhbiBmbGFncyBhbGxvd3MgU2VsZWN0IHRvIG9wZXJhdGUgd2hlbiBub2RlcyBoYXZlIG5vdFxuYmVlbiBjcmVhdGVkIGZvciByb3dzIC8gY2VsbHMgKERhdGFUYWJsZXMnIGRlZmVyIHJlbmRlcmluZyBmZWF0dXJlKS5cblxuIyMgQVBJIG1ldGhvZHNcblxuQSByYW5nZSBvZiBBUEkgbWV0aG9kcyBhcmUgYXZhaWxhYmxlIGZvciB0cmlnZ2VyaW5nIHNlbGVjdGlvbiBhbmQgZGUtc2VsZWN0aW9uXG5vZiByb3dzLiBNZXRob2RzIGFyZSBhbHNvIGF2YWlsYWJsZSB0byBjb25maWd1cmUgdGhlIHNlbGVjdGlvbiBldmVudHMgdGhhdCBjYW5cbmJlIHRyaWdnZXJlZCBieSBhbiBlbmQgdXNlciAoc3VjaCBhcyB3aGljaCBpdGVtcyBhcmUgdG8gYmUgc2VsZWN0ZWQpLiBUbyBhIGxhcmdlXG5leHRlbnQsIHRoZXNlIG9mIEFQSSBtZXRob2RzICppcyogU2VsZWN0LiBJdCBpcyBiYXNpY2FsbHkgYSBjb2xsZWN0aW9uIG9mIGhlbHBlclxuZnVuY3Rpb25zIHRoYXQgY2FuIGJlIHVzZWQgdG8gc2VsZWN0IGl0ZW1zIGluIGEgRGF0YVRhYmxlLlxuXG5Db25maWd1cmF0aW9uIG9mIHNlbGVjdCBpcyBoZWxkIGluIHRoZSBvYmplY3QgYF9zZWxlY3RgIHdoaWNoIGlzIGF0dGFjaGVkIHRvIHRoZVxuRGF0YVRhYmxlcyBzZXR0aW5ncyBvYmplY3Qgb24gaW5pdGlhbGlzYXRpb24uIFNlbGVjdCBiZWluZyBhdmFpbGFibGUgb24gYSB0YWJsZVxuaXMgbm90IG9wdGlvbmFsIHdoZW4gU2VsZWN0IGlzIGxvYWRlZCwgYnV0IGl0cyBkZWZhdWx0IGlzIGZvciBzZWxlY3Rpb24gb25seSB0b1xuYmUgYXZhaWxhYmxlIHZpYSB0aGUgQVBJIC0gc28gdGhlIGVuZCB1c2VyIHdvdWxkbid0IGJlIGFibGUgdG8gc2VsZWN0IHJvd3NcbndpdGhvdXQgYWRkaXRpb25hbCBjb25maWd1cmF0aW9uLlxuXG5UaGUgYF9zZWxlY3RgIG9iamVjdCBjb250YWlucyB0aGUgZm9sbG93aW5nIHByb3BlcnRpZXM6XG5cbmBgYFxue1xuXHRpdGVtczpzdHJpbmcgICAgICAgLSBDYW4gYmUgYHJvd3NgLCBgY29sdW1uc2Agb3IgYGNlbGxzYC4gRGVmaW5lcyB3aGF0IGl0ZW0gXG5cdCAgICAgICAgICAgICAgICAgICAgIHdpbGwgYmUgc2VsZWN0ZWQgaWYgdGhlIHVzZXIgaXMgYWxsb3dlZCB0byBhY3RpdmF0ZSByb3dcblx0ICAgICAgICAgICAgICAgICAgICAgc2VsZWN0aW9uIHVzaW5nIHRoZSBtb3VzZS5cblx0c3R5bGU6c3RyaW5nICAgICAgIC0gQ2FuIGJlIGBub25lYCwgYHNpbmdsZWAsIGBtdWx0aWAgb3IgYG9zYC4gRGVmaW5lcyB0aGVcblx0ICAgICAgICAgICAgICAgICAgICAgaW50ZXJhY3Rpb24gc3R5bGUgd2hlbiBzZWxlY3RpbmcgaXRlbXNcblx0Ymx1cmFibGU6Ym9vbGVhbiAgIC0gSWYgcm93IHNlbGVjdGlvbiBjYW4gYmUgY2xlYXJlZCBieSBjbGlja2luZyBvdXRzaWRlIG9mXG5cdCAgICAgICAgICAgICAgICAgICAgIHRoZSB0YWJsZVxuXHR0b2dnbGVhYmxlOmJvb2xlYW4gLSBJZiByb3cgc2VsZWN0aW9uIGNhbiBiZSBjYW5jZWxsZWQgYnkgcmVwZWF0ZWQgY2xpY2tpbmdcblx0ICAgICAgICAgICAgICAgICAgICAgb24gdGhlIHJvd1xuXHRpbmZvOmJvb2xlYW4gICAgICAgLSBJZiB0aGUgc2VsZWN0aW9uIHN1bW1hcnkgc2hvdWxkIGJlIHNob3duIGluIHRoZSB0YWJsZVxuXHQgICAgICAgICAgICAgICAgICAgICBpbmZvcm1hdGlvbiBlbGVtZW50c1xufVxuYGBgXG5cbkluIGFkZGl0aW9uIHRvIHRoZSBBUEkgbWV0aG9kcywgU2VsZWN0IGFsc28gZXh0ZW5kcyB0aGUgRGF0YVRhYmxlcyBzZWxlY3Rvclxub3B0aW9ucyBmb3Igcm93cywgY29sdW1ucyBhbmQgY2VsbHMgYWRkaW5nIGEgYHNlbGVjdGVkYCBvcHRpb24gdG8gdGhlIHNlbGVjdG9yXG5vcHRpb25zIG9iamVjdCwgYWxsb3dpbmcgdGhlIGRldmVsb3BlciB0byBzZWxlY3Qgb25seSBzZWxlY3RlZCBpdGVtcyBvclxudW5zZWxlY3RlZCBpdGVtcy5cblxuIyMgTW91c2Ugc2VsZWN0aW9uIG9mIGl0ZW1zXG5cbkNsaWNraW5nIG9uIGl0ZW1zIGNhbiBiZSB1c2VkIHRvIHNlbGVjdCBpdGVtcy4gVGhpcyBpcyBkb25lIGJ5IGEgc2ltcGxlIGV2ZW50XG5oYW5kbGVyIHRoYXQgd2lsbCBzZWxlY3QgdGhlIGl0ZW1zIHVzaW5nIHRoZSBBUEkgbWV0aG9kcy5cblxuICovXG5cblxuLyogKiAqICogKiAqICogKiAqICogKiAqICogKiAqICogKiAqICogKiAqICogKiAqICogKiAqICogKiAqICogKiAqICogKiAqICogKiAqICpcbiAqIExvY2FsIGZ1bmN0aW9uc1xuICovXG5cbi8qKlxuICogQWRkIG9uZSBvciBtb3JlIGNlbGxzIHRvIHRoZSBzZWxlY3Rpb24gd2hlbiBzaGlmdCBjbGlja2luZyBpbiBPUyBzZWxlY3Rpb25cbiAqIHN0eWxlIGNlbGwgc2VsZWN0aW9uLlxuICpcbiAqIENlbGwgcmFuZ2UgaXMgbW9yZSBjb21wbGljYXRlZCB0aGFuIHJvdyBhbmQgY29sdW1uIGFzIHdlIHdhbnQgdG8gc2VsZWN0XG4gKiBpbiB0aGUgdmlzaWJsZSBncmlkIHJhdGhlciB0aGFuIGJ5IGluZGV4IGluIHNlcXVlbmNlLiBGb3IgZXhhbXBsZSwgaWYgeW91XG4gKiBjbGljayBmaXJzdCBpbiBjZWxsIDEtMSBhbmQgdGhlbiBzaGlmdCBjbGljayBpbiAyLTIgLSBjZWxscyAxLTIgYW5kIDItMVxuICogc2hvdWxkIGFsc28gYmUgc2VsZWN0ZWQgKGFuZCBub3QgMS0zLCAxLTQuIGV0YylcbiAqIFxuICogQHBhcmFtICB7RGF0YVRhYmxlLkFwaX0gZHQgICBEYXRhVGFibGVcbiAqIEBwYXJhbSAge29iamVjdH0gICAgICAgIGlkeCAgQ2VsbCBpbmRleCB0byBzZWxlY3QgdG9cbiAqIEBwYXJhbSAge29iamVjdH0gICAgICAgIGxhc3QgQ2VsbCBpbmRleCB0byBzZWxlY3QgZnJvbVxuICogQHByaXZhdGVcbiAqL1xuZnVuY3Rpb24gY2VsbFJhbmdlKCBkdCwgaWR4LCBsYXN0IClcbntcblx0dmFyIGluZGV4ZXM7XG5cdHZhciBjb2x1bW5JbmRleGVzO1xuXHR2YXIgcm93SW5kZXhlcztcblx0dmFyIHNlbGVjdENvbHVtbnMgPSBmdW5jdGlvbiAoIHN0YXJ0LCBlbmQgKSB7XG5cdFx0aWYgKCBzdGFydCA+IGVuZCApIHtcblx0XHRcdHZhciB0bXAgPSBlbmQ7XG5cdFx0XHRlbmQgPSBzdGFydDtcblx0XHRcdHN0YXJ0ID0gdG1wO1xuXHRcdH1cblx0XHRcblx0XHR2YXIgcmVjb3JkID0gZmFsc2U7XG5cdFx0cmV0dXJuIGR0LmNvbHVtbnMoICc6dmlzaWJsZScgKS5pbmRleGVzKCkuZmlsdGVyKCBmdW5jdGlvbiAoaSkge1xuXHRcdFx0aWYgKCBpID09PSBzdGFydCApIHtcblx0XHRcdFx0cmVjb3JkID0gdHJ1ZTtcblx0XHRcdH1cblx0XHRcdFxuXHRcdFx0aWYgKCBpID09PSBlbmQgKSB7IC8vIG5vdCBlbHNlIGlmLCBhcyBzdGFydCBtaWdodCA9PT0gZW5kXG5cdFx0XHRcdHJlY29yZCA9IGZhbHNlO1xuXHRcdFx0XHRyZXR1cm4gdHJ1ZTtcblx0XHRcdH1cblxuXHRcdFx0cmV0dXJuIHJlY29yZDtcblx0XHR9ICk7XG5cdH07XG5cblx0dmFyIHNlbGVjdFJvd3MgPSBmdW5jdGlvbiAoIHN0YXJ0LCBlbmQgKSB7XG5cdFx0dmFyIGluZGV4ZXMgPSBkdC5yb3dzKCB7IHNlYXJjaDogJ2FwcGxpZWQnIH0gKS5pbmRleGVzKCk7XG5cblx0XHQvLyBXaGljaCBjb21lcyBmaXJzdCAtIG1pZ2h0IG5lZWQgdG8gc3dhcFxuXHRcdGlmICggaW5kZXhlcy5pbmRleE9mKCBzdGFydCApID4gaW5kZXhlcy5pbmRleE9mKCBlbmQgKSApIHtcblx0XHRcdHZhciB0bXAgPSBlbmQ7XG5cdFx0XHRlbmQgPSBzdGFydDtcblx0XHRcdHN0YXJ0ID0gdG1wO1xuXHRcdH1cblxuXHRcdHZhciByZWNvcmQgPSBmYWxzZTtcblx0XHRyZXR1cm4gaW5kZXhlcy5maWx0ZXIoIGZ1bmN0aW9uIChpKSB7XG5cdFx0XHRpZiAoIGkgPT09IHN0YXJ0ICkge1xuXHRcdFx0XHRyZWNvcmQgPSB0cnVlO1xuXHRcdFx0fVxuXHRcdFx0XG5cdFx0XHRpZiAoIGkgPT09IGVuZCApIHtcblx0XHRcdFx0cmVjb3JkID0gZmFsc2U7XG5cdFx0XHRcdHJldHVybiB0cnVlO1xuXHRcdFx0fVxuXG5cdFx0XHRyZXR1cm4gcmVjb3JkO1xuXHRcdH0gKTtcblx0fTtcblxuXHRpZiAoICEgZHQuY2VsbHMoIHsgc2VsZWN0ZWQ6IHRydWUgfSApLmFueSgpICYmICEgbGFzdCApIHtcblx0XHQvLyBzZWxlY3QgZnJvbSB0aGUgdG9wIGxlZnQgY2VsbCB0byB0aGlzIG9uZVxuXHRcdGNvbHVtbkluZGV4ZXMgPSBzZWxlY3RDb2x1bW5zKCAwLCBpZHguY29sdW1uICk7XG5cdFx0cm93SW5kZXhlcyA9IHNlbGVjdFJvd3MoIDAgLCBpZHgucm93ICk7XG5cdH1cblx0ZWxzZSB7XG5cdFx0Ly8gR2V0IGNvbHVtbiBpbmRleGVzIGJldHdlZW4gb2xkIGFuZCBuZXdcblx0XHRjb2x1bW5JbmRleGVzID0gc2VsZWN0Q29sdW1ucyggbGFzdC5jb2x1bW4sIGlkeC5jb2x1bW4gKTtcblx0XHRyb3dJbmRleGVzID0gc2VsZWN0Um93cyggbGFzdC5yb3cgLCBpZHgucm93ICk7XG5cdH1cblxuXHRpbmRleGVzID0gZHQuY2VsbHMoIHJvd0luZGV4ZXMsIGNvbHVtbkluZGV4ZXMgKS5mbGF0dGVuKCk7XG5cblx0aWYgKCAhIGR0LmNlbGxzKCBpZHgsIHsgc2VsZWN0ZWQ6IHRydWUgfSApLmFueSgpICkge1xuXHRcdC8vIFNlbGVjdCByYW5nZVxuXHRcdGR0LmNlbGxzKCBpbmRleGVzICkuc2VsZWN0KCk7XG5cdH1cblx0ZWxzZSB7XG5cdFx0Ly8gRGVzZWxlY3QgcmFuZ2Vcblx0XHRkdC5jZWxscyggaW5kZXhlcyApLmRlc2VsZWN0KCk7XG5cdH1cbn1cblxuLyoqXG4gKiBEaXNhYmxlIG1vdXNlIHNlbGVjdGlvbiBieSByZW1vdmluZyB0aGUgc2VsZWN0b3JzXG4gKlxuICogQHBhcmFtIHtEYXRhVGFibGUuQXBpfSBkdCBEYXRhVGFibGUgdG8gcmVtb3ZlIGV2ZW50cyBmcm9tXG4gKiBAcHJpdmF0ZVxuICovXG5mdW5jdGlvbiBkaXNhYmxlTW91c2VTZWxlY3Rpb24oIGR0IClcbntcblx0dmFyIGN0eCA9IGR0LnNldHRpbmdzKClbMF07XG5cdHZhciBzZWxlY3RvciA9IGN0eC5fc2VsZWN0LnNlbGVjdG9yO1xuXG5cdCQoIGR0LnRhYmxlKCkuY29udGFpbmVyKCkgKVxuXHRcdC5vZmYoICdtb3VzZWRvd24uZHRTZWxlY3QnLCBzZWxlY3RvciApXG5cdFx0Lm9mZiggJ21vdXNldXAuZHRTZWxlY3QnLCBzZWxlY3RvciApXG5cdFx0Lm9mZiggJ2NsaWNrLmR0U2VsZWN0Jywgc2VsZWN0b3IgKTtcblxuXHQkKCdib2R5Jykub2ZmKCAnY2xpY2suZHRTZWxlY3QnICsgX3NhZmVJZChkdC50YWJsZSgpLm5vZGUoKSkgKTtcbn1cblxuLyoqXG4gKiBBdHRhY2ggbW91c2UgbGlzdGVuZXJzIHRvIHRoZSB0YWJsZSB0byBhbGxvdyBtb3VzZSBzZWxlY3Rpb24gb2YgaXRlbXNcbiAqXG4gKiBAcGFyYW0ge0RhdGFUYWJsZS5BcGl9IGR0IERhdGFUYWJsZSB0byByZW1vdmUgZXZlbnRzIGZyb21cbiAqIEBwcml2YXRlXG4gKi9cbmZ1bmN0aW9uIGVuYWJsZU1vdXNlU2VsZWN0aW9uICggZHQgKVxue1xuXHR2YXIgY29udGFpbmVyID0gJCggZHQudGFibGUoKS5jb250YWluZXIoKSApO1xuXHR2YXIgY3R4ID0gZHQuc2V0dGluZ3MoKVswXTtcblx0dmFyIHNlbGVjdG9yID0gY3R4Ll9zZWxlY3Quc2VsZWN0b3I7XG5cdHZhciBtYXRjaFNlbGVjdGlvbjtcblxuXHRjb250YWluZXJcblx0XHQub24oICdtb3VzZWRvd24uZHRTZWxlY3QnLCBzZWxlY3RvciwgZnVuY3Rpb24oZSkge1xuXHRcdFx0Ly8gRGlzYWxsb3cgdGV4dCBzZWxlY3Rpb24gZm9yIHNoaWZ0IGNsaWNraW5nIG9uIHRoZSB0YWJsZSBzbyBtdWx0aVxuXHRcdFx0Ly8gZWxlbWVudCBzZWxlY3Rpb24gZG9lc24ndCBsb29rIHRlcnJpYmxlIVxuXHRcdFx0aWYgKCBlLnNoaWZ0S2V5IHx8IGUubWV0YUtleSB8fCBlLmN0cmxLZXkgKSB7XG5cdFx0XHRcdGNvbnRhaW5lclxuXHRcdFx0XHRcdC5jc3MoICctbW96LXVzZXItc2VsZWN0JywgJ25vbmUnIClcblx0XHRcdFx0XHQub25lKCdzZWxlY3RzdGFydC5kdFNlbGVjdCcsIHNlbGVjdG9yLCBmdW5jdGlvbiAoKSB7XG5cdFx0XHRcdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0XHRcdFx0fSApO1xuXHRcdFx0fVxuXG5cdFx0XHRpZiAoIHdpbmRvdy5nZXRTZWxlY3Rpb24gKSB7XG5cdFx0XHRcdG1hdGNoU2VsZWN0aW9uID0gd2luZG93LmdldFNlbGVjdGlvbigpO1xuXHRcdFx0fVxuXHRcdH0gKVxuXHRcdC5vbiggJ21vdXNldXAuZHRTZWxlY3QnLCBzZWxlY3RvciwgZnVuY3Rpb24oKSB7XG5cdFx0XHQvLyBBbGxvdyB0ZXh0IHNlbGVjdGlvbiB0byBvY2N1ciBhZ2FpbiwgTW96aWxsYSBzdHlsZSAodGVzdGVkIGluIEZGXG5cdFx0XHQvLyAzNS4wLjEgLSBzdGlsbCByZXF1aXJlZClcblx0XHRcdGNvbnRhaW5lci5jc3MoICctbW96LXVzZXItc2VsZWN0JywgJycgKTtcblx0XHR9IClcblx0XHQub24oICdjbGljay5kdFNlbGVjdCcsIHNlbGVjdG9yLCBmdW5jdGlvbiAoIGUgKSB7XG5cdFx0XHR2YXIgaXRlbXMgPSBkdC5zZWxlY3QuaXRlbXMoKTtcblx0XHRcdHZhciBpZHg7XG5cblx0XHRcdC8vIElmIHRleHQgd2FzIHNlbGVjdGVkIChjbGljayBhbmQgZHJhZyksIHRoZW4gd2Ugc2hvdWxkbid0IGNoYW5nZVxuXHRcdFx0Ly8gdGhlIHJvdydzIHNlbGVjdGVkIHN0YXRlXG5cdFx0XHRpZiAoIG1hdGNoU2VsZWN0aW9uICkge1xuXHRcdFx0XHR2YXIgc2VsZWN0aW9uID0gd2luZG93LmdldFNlbGVjdGlvbigpO1xuXG5cdFx0XHRcdC8vIElmIHRoZSBlbGVtZW50IHRoYXQgY29udGFpbnMgdGhlIHNlbGVjdGlvbiBpcyBub3QgaW4gdGhlIHRhYmxlLCB3ZSBjYW4gaWdub3JlIGl0XG5cdFx0XHRcdC8vIFRoaXMgY2FuIGhhcHBlbiBpZiB0aGUgZGV2ZWxvcGVyIHNlbGVjdHMgdGV4dCBmcm9tIHRoZSBjbGljayBldmVudFxuXHRcdFx0XHRpZiAoICEgc2VsZWN0aW9uLmFuY2hvck5vZGUgfHwgJChzZWxlY3Rpb24uYW5jaG9yTm9kZSkuY2xvc2VzdCgndGFibGUnKVswXSA9PT0gZHQudGFibGUoKS5ub2RlKCkgKSB7XG5cdFx0XHRcdFx0aWYgKCBzZWxlY3Rpb24gIT09IG1hdGNoU2VsZWN0aW9uICkge1xuXHRcdFx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0fVxuXG5cdFx0XHR2YXIgY3R4ID0gZHQuc2V0dGluZ3MoKVswXTtcblx0XHRcdHZhciB3cmFwcGVyQ2xhc3MgPSBkdC5zZXR0aW5ncygpWzBdLm9DbGFzc2VzLnNXcmFwcGVyLnRyaW0oKS5yZXBsYWNlKC8gKy9nLCAnLicpO1xuXG5cdFx0XHQvLyBJZ25vcmUgY2xpY2tzIGluc2lkZSBhIHN1Yi10YWJsZVxuXHRcdFx0aWYgKCAkKGUudGFyZ2V0KS5jbG9zZXN0KCdkaXYuJyt3cmFwcGVyQ2xhc3MpWzBdICE9IGR0LnRhYmxlKCkuY29udGFpbmVyKCkgKSB7XG5cdFx0XHRcdHJldHVybjtcblx0XHRcdH1cblxuXHRcdFx0dmFyIGNlbGwgPSBkdC5jZWxsKCAkKGUudGFyZ2V0KS5jbG9zZXN0KCd0ZCwgdGgnKSApO1xuXG5cdFx0XHQvLyBDaGVjayB0aGUgY2VsbCBhY3R1YWxseSBiZWxvbmdzIHRvIHRoZSBob3N0IERhdGFUYWJsZSAoc28gY2hpbGRcblx0XHRcdC8vIHJvd3MsIGV0YywgYXJlIGlnbm9yZWQpXG5cdFx0XHRpZiAoICEgY2VsbC5hbnkoKSApIHtcblx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0fVxuXG5cdFx0XHR2YXIgZXZlbnQgPSAkLkV2ZW50KCd1c2VyLXNlbGVjdC5kdCcpO1xuXHRcdFx0ZXZlbnRUcmlnZ2VyKCBkdCwgZXZlbnQsIFsgaXRlbXMsIGNlbGwsIGUgXSApO1xuXG5cdFx0XHRpZiAoIGV2ZW50LmlzRGVmYXVsdFByZXZlbnRlZCgpICkge1xuXHRcdFx0XHRyZXR1cm47XG5cdFx0XHR9XG5cblx0XHRcdHZhciBjZWxsSW5kZXggPSBjZWxsLmluZGV4KCk7XG5cdFx0XHRpZiAoIGl0ZW1zID09PSAncm93JyApIHtcblx0XHRcdFx0aWR4ID0gY2VsbEluZGV4LnJvdztcblx0XHRcdFx0dHlwZVNlbGVjdCggZSwgZHQsIGN0eCwgJ3JvdycsIGlkeCApO1xuXHRcdFx0fVxuXHRcdFx0ZWxzZSBpZiAoIGl0ZW1zID09PSAnY29sdW1uJyApIHtcblx0XHRcdFx0aWR4ID0gY2VsbC5pbmRleCgpLmNvbHVtbjtcblx0XHRcdFx0dHlwZVNlbGVjdCggZSwgZHQsIGN0eCwgJ2NvbHVtbicsIGlkeCApO1xuXHRcdFx0fVxuXHRcdFx0ZWxzZSBpZiAoIGl0ZW1zID09PSAnY2VsbCcgKSB7XG5cdFx0XHRcdGlkeCA9IGNlbGwuaW5kZXgoKTtcblx0XHRcdFx0dHlwZVNlbGVjdCggZSwgZHQsIGN0eCwgJ2NlbGwnLCBpZHggKTtcblx0XHRcdH1cblxuXHRcdFx0Y3R4Ll9zZWxlY3RfbGFzdENlbGwgPSBjZWxsSW5kZXg7XG5cdFx0fSApO1xuXG5cdC8vIEJsdXJhYmxlXG5cdCQoJ2JvZHknKS5vbiggJ2NsaWNrLmR0U2VsZWN0JyArIF9zYWZlSWQoZHQudGFibGUoKS5ub2RlKCkpLCBmdW5jdGlvbiAoIGUgKSB7XG5cdFx0aWYgKCBjdHguX3NlbGVjdC5ibHVyYWJsZSApIHtcblx0XHRcdC8vIElmIHRoZSBjbGljayB3YXMgaW5zaWRlIHRoZSBEYXRhVGFibGVzIGNvbnRhaW5lciwgZG9uJ3QgYmx1clxuXHRcdFx0aWYgKCAkKGUudGFyZ2V0KS5wYXJlbnRzKCkuZmlsdGVyKCBkdC50YWJsZSgpLmNvbnRhaW5lcigpICkubGVuZ3RoICkge1xuXHRcdFx0XHRyZXR1cm47XG5cdFx0XHR9XG5cblx0XHRcdC8vIElnbm9yZSBlbGVtZW50cyB3aGljaCBoYXZlIGJlZW4gcmVtb3ZlZCBmcm9tIHRoZSBET00gKGkuZS4gcGFnaW5nXG5cdFx0XHQvLyBidXR0b25zKVxuXHRcdFx0aWYgKCAkKGUudGFyZ2V0KS5wYXJlbnRzKCdodG1sJykubGVuZ3RoID09PSAwICkge1xuXHRcdFx0IFx0cmV0dXJuO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBEb24ndCBibHVyIGluIEVkaXRvciBmb3JtXG5cdFx0XHRpZiAoICQoZS50YXJnZXQpLnBhcmVudHMoJ2Rpdi5EVEUnKS5sZW5ndGggKSB7XG5cdFx0XHRcdHJldHVybjtcblx0XHRcdH1cblxuXHRcdFx0Y2xlYXIoIGN0eCwgdHJ1ZSApO1xuXHRcdH1cblx0fSApO1xufVxuXG4vKipcbiAqIFRyaWdnZXIgYW4gZXZlbnQgb24gYSBEYXRhVGFibGVcbiAqXG4gKiBAcGFyYW0ge0RhdGFUYWJsZS5BcGl9IGFwaSAgICAgIERhdGFUYWJsZSB0byB0cmlnZ2VyIGV2ZW50cyBvblxuICogQHBhcmFtICB7Ym9vbGVhbn0gICAgICBzZWxlY3RlZCB0cnVlIGlmIHNlbGVjdGVkLCBmYWxzZSBpZiBkZXNlbGVjdGVkXG4gKiBAcGFyYW0gIHtzdHJpbmd9ICAgICAgIHR5cGUgICAgIEl0ZW0gdHlwZSBhY3Rpbmcgb25cbiAqIEBwYXJhbSAge2Jvb2xlYW59ICAgICAgYW55ICAgICAgUmVxdWlyZSB0aGF0IHRoZXJlIGFyZSB2YWx1ZXMgYmVmb3JlXG4gKiAgICAgdHJpZ2dlcmluZ1xuICogQHByaXZhdGVcbiAqL1xuZnVuY3Rpb24gZXZlbnRUcmlnZ2VyICggYXBpLCB0eXBlLCBhcmdzLCBhbnkgKVxue1xuXHRpZiAoIGFueSAmJiAhIGFwaS5mbGF0dGVuKCkubGVuZ3RoICkge1xuXHRcdHJldHVybjtcblx0fVxuXG5cdGlmICggdHlwZW9mIHR5cGUgPT09ICdzdHJpbmcnICkge1xuXHRcdHR5cGUgPSB0eXBlICsnLmR0Jztcblx0fVxuXG5cdGFyZ3MudW5zaGlmdCggYXBpICk7XG5cblx0JChhcGkudGFibGUoKS5ub2RlKCkpLnRyaWdnZXIoIHR5cGUsIGFyZ3MgKTtcbn1cblxuLyoqXG4gKiBVcGRhdGUgdGhlIGluZm9ybWF0aW9uIGVsZW1lbnQgb2YgdGhlIERhdGFUYWJsZSBzaG93aW5nIGluZm9ybWF0aW9uIGFib3V0IHRoZVxuICogaXRlbXMgc2VsZWN0ZWQuIFRoaXMgaXMgZG9uZSBieSBhZGRpbmcgdGFncyB0byB0aGUgZXhpc3RpbmcgdGV4dFxuICogXG4gKiBAcGFyYW0ge0RhdGFUYWJsZS5BcGl9IGFwaSBEYXRhVGFibGUgdG8gdXBkYXRlXG4gKiBAcHJpdmF0ZVxuICovXG5mdW5jdGlvbiBpbmZvICggYXBpIClcbntcblx0dmFyIGN0eCA9IGFwaS5zZXR0aW5ncygpWzBdO1xuXG5cdGlmICggISBjdHguX3NlbGVjdC5pbmZvIHx8ICEgY3R4LmFhbkZlYXR1cmVzLmkgKSB7XG5cdFx0cmV0dXJuO1xuXHR9XG5cblx0aWYgKCBhcGkuc2VsZWN0LnN0eWxlKCkgPT09ICdhcGknICkge1xuXHRcdHJldHVybjtcblx0fVxuXG5cdHZhciByb3dzICAgID0gYXBpLnJvd3MoIHsgc2VsZWN0ZWQ6IHRydWUgfSApLmZsYXR0ZW4oKS5sZW5ndGg7XG5cdHZhciBjb2x1bW5zID0gYXBpLmNvbHVtbnMoIHsgc2VsZWN0ZWQ6IHRydWUgfSApLmZsYXR0ZW4oKS5sZW5ndGg7XG5cdHZhciBjZWxscyAgID0gYXBpLmNlbGxzKCB7IHNlbGVjdGVkOiB0cnVlIH0gKS5mbGF0dGVuKCkubGVuZ3RoO1xuXG5cdHZhciBhZGQgPSBmdW5jdGlvbiAoIGVsLCBuYW1lLCBudW0gKSB7XG5cdFx0ZWwuYXBwZW5kKCAkKCc8c3BhbiBjbGFzcz1cInNlbGVjdC1pdGVtXCIvPicpLmFwcGVuZCggYXBpLmkxOG4oXG5cdFx0XHQnc2VsZWN0LicrbmFtZSsncycsXG5cdFx0XHR7IF86ICclZCAnK25hbWUrJ3Mgc2VsZWN0ZWQnLCAwOiAnJywgMTogJzEgJytuYW1lKycgc2VsZWN0ZWQnIH0sXG5cdFx0XHRudW1cblx0XHQpICkgKTtcblx0fTtcblxuXHQvLyBJbnRlcm5hbCBrbm93bGVkZ2Ugb2YgRGF0YVRhYmxlcyB0byBsb29wIG92ZXIgYWxsIGluZm9ybWF0aW9uIGVsZW1lbnRzXG5cdCQuZWFjaCggY3R4LmFhbkZlYXR1cmVzLmksIGZ1bmN0aW9uICggaSwgZWwgKSB7XG5cdFx0ZWwgPSAkKGVsKTtcblxuXHRcdHZhciBvdXRwdXQgID0gJCgnPHNwYW4gY2xhc3M9XCJzZWxlY3QtaW5mb1wiLz4nKTtcblx0XHRhZGQoIG91dHB1dCwgJ3JvdycsIHJvd3MgKTtcblx0XHRhZGQoIG91dHB1dCwgJ2NvbHVtbicsIGNvbHVtbnMgKTtcblx0XHRhZGQoIG91dHB1dCwgJ2NlbGwnLCBjZWxscyAgKTtcblxuXHRcdHZhciBleGlzaXRpbmcgPSBlbC5jaGlsZHJlbignc3Bhbi5zZWxlY3QtaW5mbycpO1xuXHRcdGlmICggZXhpc2l0aW5nLmxlbmd0aCApIHtcblx0XHRcdGV4aXNpdGluZy5yZW1vdmUoKTtcblx0XHR9XG5cblx0XHRpZiAoIG91dHB1dC50ZXh0KCkgIT09ICcnICkge1xuXHRcdFx0ZWwuYXBwZW5kKCBvdXRwdXQgKTtcblx0XHR9XG5cdH0gKTtcbn1cblxuLyoqXG4gKiBJbml0aWFsaXNhdGlvbiBvZiBhIG5ldyB0YWJsZS4gQXR0YWNoIGV2ZW50IGhhbmRsZXJzIGFuZCBjYWxsYmFja3MgdG8gYWxsb3dcbiAqIFNlbGVjdCB0byBvcGVyYXRlIGNvcnJlY3RseS5cbiAqXG4gKiBUaGlzIHdpbGwgb2NjdXIgX2FmdGVyXyB0aGUgaW5pdGlhbCBEYXRhVGFibGVzIGluaXRpYWxpc2F0aW9uLCBhbHRob3VnaFxuICogYmVmb3JlIEFqYXggZGF0YSBpcyByZW5kZXJlZCwgaWYgdGhlcmUgaXMgYWpheCBkYXRhXG4gKlxuICogQHBhcmFtICB7RGF0YVRhYmxlLnNldHRpbmdzfSBjdHggU2V0dGluZ3Mgb2JqZWN0IHRvIG9wZXJhdGUgb25cbiAqIEBwcml2YXRlXG4gKi9cbmZ1bmN0aW9uIGluaXQgKCBjdHggKSB7XG5cdHZhciBhcGkgPSBuZXcgRGF0YVRhYmxlLkFwaSggY3R4ICk7XG5cdGN0eC5fc2VsZWN0X2luaXQgPSB0cnVlO1xuXG5cdC8vIFJvdyBjYWxsYmFjayBzbyB0aGF0IGNsYXNzZXMgY2FuIGJlIGFkZGVkIHRvIHJvd3MgYW5kIGNlbGxzIGlmIHRoZSBpdGVtXG5cdC8vIHdhcyBzZWxlY3RlZCBiZWZvcmUgdGhlIGVsZW1lbnQgd2FzIGNyZWF0ZWQuIFRoaXMgd2lsbCBoYXBwZW4gd2l0aCB0aGVcblx0Ly8gYGRlZmVyUmVuZGVyYCBvcHRpb24gZW5hYmxlZC5cblx0Ly8gXG5cdC8vIFRoaXMgbWV0aG9kIG9mIGF0dGFjaGluZyB0byBgYW9Sb3dDcmVhdGVkQ2FsbGJhY2tgIGlzIGEgaGFjayB1bnRpbFxuXHQvLyBEYXRhVGFibGVzIGhhcyBwcm9wZXIgZXZlbnRzIGZvciByb3cgbWFuaXB1bGF0aW9uIElmIHlvdSBhcmUgcmV2aWV3aW5nXG5cdC8vIHRoaXMgY29kZSB0byBjcmVhdGUgeW91ciBvd24gcGx1Zy1pbnMsIHBsZWFzZSBkbyBub3QgZG8gdGhpcyFcblx0Y3R4LmFvUm93Q3JlYXRlZENhbGxiYWNrLnB1c2goIHtcblx0XHRmbjogZnVuY3Rpb24gKCByb3csIGRhdGEsIGluZGV4ICkge1xuXHRcdFx0dmFyIGksIGllbjtcblx0XHRcdHZhciBkID0gY3R4LmFvRGF0YVsgaW5kZXggXTtcblxuXHRcdFx0Ly8gUm93XG5cdFx0XHRpZiAoIGQuX3NlbGVjdF9zZWxlY3RlZCApIHtcblx0XHRcdFx0JCggcm93ICkuYWRkQ2xhc3MoIGN0eC5fc2VsZWN0LmNsYXNzTmFtZSApO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBDZWxscyBhbmQgY29sdW1ucyAtIGlmIHNlcGFyYXRlZCBvdXQsIHdlIHdvdWxkIG5lZWQgdG8gZG8gdHdvXG5cdFx0XHQvLyBsb29wcywgc28gaXQgbWFrZXMgc2Vuc2UgdG8gY29tYmluZSB0aGVtIGludG8gYSBzaW5nbGUgb25lXG5cdFx0XHRmb3IgKCBpPTAsIGllbj1jdHguYW9Db2x1bW5zLmxlbmd0aCA7IGk8aWVuIDsgaSsrICkge1xuXHRcdFx0XHRpZiAoIGN0eC5hb0NvbHVtbnNbaV0uX3NlbGVjdF9zZWxlY3RlZCB8fCAoZC5fc2VsZWN0ZWRfY2VsbHMgJiYgZC5fc2VsZWN0ZWRfY2VsbHNbaV0pICkge1xuXHRcdFx0XHRcdCQoZC5hbkNlbGxzW2ldKS5hZGRDbGFzcyggY3R4Ll9zZWxlY3QuY2xhc3NOYW1lICk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9LFxuXHRcdHNOYW1lOiAnc2VsZWN0LWRlZmVyUmVuZGVyJ1xuXHR9ICk7XG5cblx0Ly8gT24gQWpheCByZWxvYWQgd2Ugd2FudCB0byByZXNlbGVjdCBhbGwgcm93cyB3aGljaCBhcmUgY3VycmVudGx5IHNlbGVjdGVkLFxuXHQvLyBpZiB0aGVyZSBpcyBhbiByb3dJZCAoaS5lLiBhIHVuaXF1ZSB2YWx1ZSB0byBpZGVudGlmeSBlYWNoIHJvdyB3aXRoKVxuXHRhcGkub24oICdwcmVYaHIuZHQuZHRTZWxlY3QnLCBmdW5jdGlvbiAoZSwgc2V0dGluZ3MpIHtcblx0XHRpZiAoc2V0dGluZ3MgIT09IGFwaS5zZXR0aW5ncygpWzBdKSB7XG5cdFx0XHQvLyBOb3QgdHJpZ2dlcmVkIGJ5IG91ciBEYXRhVGFibGUhXG5cdFx0XHRyZXR1cm47XG5cdFx0fVxuXG5cdFx0Ly8gbm90ZSB0aGF0IGNvbHVtbiBzZWxlY3Rpb24gZG9lc24ndCBuZWVkIHRvIGJlIGNhY2hlZCBhbmQgdGhlblxuXHRcdC8vIHJlc2VsZWN0ZWQsIGFzIHRoZXkgYXJlIGFscmVhZHkgc2VsZWN0ZWRcblx0XHR2YXIgcm93cyA9IGFwaS5yb3dzKCB7IHNlbGVjdGVkOiB0cnVlIH0gKS5pZHMoIHRydWUgKS5maWx0ZXIoIGZ1bmN0aW9uICggZCApIHtcblx0XHRcdHJldHVybiBkICE9PSB1bmRlZmluZWQ7XG5cdFx0fSApO1xuXG5cdFx0dmFyIGNlbGxzID0gYXBpLmNlbGxzKCB7IHNlbGVjdGVkOiB0cnVlIH0gKS5lcSgwKS5tYXAoIGZ1bmN0aW9uICggY2VsbElkeCApIHtcblx0XHRcdHZhciBpZCA9IGFwaS5yb3coIGNlbGxJZHgucm93ICkuaWQoIHRydWUgKTtcblx0XHRcdHJldHVybiBpZCA/XG5cdFx0XHRcdHsgcm93OiBpZCwgY29sdW1uOiBjZWxsSWR4LmNvbHVtbiB9IDpcblx0XHRcdFx0dW5kZWZpbmVkO1xuXHRcdH0gKS5maWx0ZXIoIGZ1bmN0aW9uICggZCApIHtcblx0XHRcdHJldHVybiBkICE9PSB1bmRlZmluZWQ7XG5cdFx0fSApO1xuXG5cdFx0Ly8gT24gdGhlIG5leHQgZHJhdywgcmVzZWxlY3QgdGhlIGN1cnJlbnRseSBzZWxlY3RlZCBpdGVtc1xuXHRcdGFwaS5vbmUoICdkcmF3LmR0LmR0U2VsZWN0JywgZnVuY3Rpb24gKCkge1xuXHRcdFx0YXBpLnJvd3MoIHJvd3MgKS5zZWxlY3QoKTtcblxuXHRcdFx0Ly8gYGNlbGxzYCBpcyBub3QgYSBjZWxsIGluZGV4IHNlbGVjdG9yLCBzbyBpdCBuZWVkcyBhIGxvb3Bcblx0XHRcdGlmICggY2VsbHMuYW55KCkgKSB7XG5cdFx0XHRcdGNlbGxzLmVhY2goIGZ1bmN0aW9uICggaWQgKSB7XG5cdFx0XHRcdFx0YXBpLmNlbGxzKCBpZC5yb3csIGlkLmNvbHVtbiApLnNlbGVjdCgpO1xuXHRcdFx0XHR9ICk7XG5cdFx0XHR9XG5cdFx0fSApO1xuXHR9ICk7XG5cblx0Ly8gVXBkYXRlIHRoZSB0YWJsZSBpbmZvcm1hdGlvbiBlbGVtZW50IHdpdGggc2VsZWN0ZWQgaXRlbSBzdW1tYXJ5XG5cdGFwaS5vbiggJ2RyYXcuZHRTZWxlY3QuZHQgc2VsZWN0LmR0U2VsZWN0LmR0IGRlc2VsZWN0LmR0U2VsZWN0LmR0IGluZm8uZHQnLCBmdW5jdGlvbiAoKSB7XG5cdFx0aW5mbyggYXBpICk7XG5cdFx0YXBpLnN0YXRlLnNhdmUoKTtcblx0fSApO1xuXG5cdC8vIENsZWFuIHVwIGFuZCByZWxlYXNlXG5cdGFwaS5vbiggJ2Rlc3Ryb3kuZHRTZWxlY3QnLCBmdW5jdGlvbiAoKSB7XG5cdFx0YXBpLnJvd3Moe3NlbGVjdGVkOiB0cnVlfSkuZGVzZWxlY3QoKTtcblxuXHRcdGRpc2FibGVNb3VzZVNlbGVjdGlvbiggYXBpICk7XG5cdFx0YXBpLm9mZiggJy5kdFNlbGVjdCcgKTtcblx0XHQkKCdib2R5Jykub2ZmKCcuZHRTZWxlY3QnICsgX3NhZmVJZChhcGkudGFibGUoKS5ub2RlKCkpKTtcblx0fSApO1xufVxuXG4vKipcbiAqIEFkZCBvbmUgb3IgbW9yZSBpdGVtcyAocm93cyBvciBjb2x1bW5zKSB0byB0aGUgc2VsZWN0aW9uIHdoZW4gc2hpZnQgY2xpY2tpbmdcbiAqIGluIE9TIHNlbGVjdGlvbiBzdHlsZVxuICpcbiAqIEBwYXJhbSAge0RhdGFUYWJsZS5BcGl9IGR0ICAgRGF0YVRhYmxlXG4gKiBAcGFyYW0gIHtzdHJpbmd9ICAgICAgICB0eXBlIFJvdyBvciBjb2x1bW4gcmFuZ2Ugc2VsZWN0b3JcbiAqIEBwYXJhbSAge29iamVjdH0gICAgICAgIGlkeCAgSXRlbSBpbmRleCB0byBzZWxlY3QgdG9cbiAqIEBwYXJhbSAge29iamVjdH0gICAgICAgIGxhc3QgSXRlbSBpbmRleCB0byBzZWxlY3QgZnJvbVxuICogQHByaXZhdGVcbiAqL1xuZnVuY3Rpb24gcm93Q29sdW1uUmFuZ2UoIGR0LCB0eXBlLCBpZHgsIGxhc3QgKVxue1xuXHQvLyBBZGQgYSByYW5nZSBvZiByb3dzIGZyb20gdGhlIGxhc3Qgc2VsZWN0ZWQgcm93IHRvIHRoaXMgb25lXG5cdHZhciBpbmRleGVzID0gZHRbdHlwZSsncyddKCB7IHNlYXJjaDogJ2FwcGxpZWQnIH0gKS5pbmRleGVzKCk7XG5cdHZhciBpZHgxID0gJC5pbkFycmF5KCBsYXN0LCBpbmRleGVzICk7XG5cdHZhciBpZHgyID0gJC5pbkFycmF5KCBpZHgsIGluZGV4ZXMgKTtcblxuXHRpZiAoICEgZHRbdHlwZSsncyddKCB7IHNlbGVjdGVkOiB0cnVlIH0gKS5hbnkoKSAmJiBpZHgxID09PSAtMSApIHtcblx0XHQvLyBzZWxlY3QgZnJvbSB0b3AgdG8gaGVyZSAtIHNsaWdodGx5IG9kZCwgYnV0IGJvdGggV2luZG93cyBhbmQgTWFjIE9TXG5cdFx0Ly8gZG8gdGhpc1xuXHRcdGluZGV4ZXMuc3BsaWNlKCAkLmluQXJyYXkoIGlkeCwgaW5kZXhlcyApKzEsIGluZGV4ZXMubGVuZ3RoICk7XG5cdH1cblx0ZWxzZSB7XG5cdFx0Ly8gcmV2ZXJzZSBzbyB3ZSBjYW4gc2hpZnQgY2xpY2sgJ3VwJyBhcyB3ZWxsIGFzIGRvd25cblx0XHRpZiAoIGlkeDEgPiBpZHgyICkge1xuXHRcdFx0dmFyIHRtcCA9IGlkeDI7XG5cdFx0XHRpZHgyID0gaWR4MTtcblx0XHRcdGlkeDEgPSB0bXA7XG5cdFx0fVxuXG5cdFx0aW5kZXhlcy5zcGxpY2UoIGlkeDIrMSwgaW5kZXhlcy5sZW5ndGggKTtcblx0XHRpbmRleGVzLnNwbGljZSggMCwgaWR4MSApO1xuXHR9XG5cblx0aWYgKCAhIGR0W3R5cGVdKCBpZHgsIHsgc2VsZWN0ZWQ6IHRydWUgfSApLmFueSgpICkge1xuXHRcdC8vIFNlbGVjdCByYW5nZVxuXHRcdGR0W3R5cGUrJ3MnXSggaW5kZXhlcyApLnNlbGVjdCgpO1xuXHR9XG5cdGVsc2Uge1xuXHRcdC8vIERlc2VsZWN0IHJhbmdlIC0gbmVlZCB0byBrZWVwIHRoZSBjbGlja2VkIG9uIHJvdyBzZWxlY3RlZFxuXHRcdGluZGV4ZXMuc3BsaWNlKCAkLmluQXJyYXkoIGlkeCwgaW5kZXhlcyApLCAxICk7XG5cdFx0ZHRbdHlwZSsncyddKCBpbmRleGVzICkuZGVzZWxlY3QoKTtcblx0fVxufVxuXG4vKipcbiAqIENsZWFyIGFsbCBzZWxlY3RlZCBpdGVtc1xuICpcbiAqIEBwYXJhbSAge0RhdGFUYWJsZS5zZXR0aW5nc30gY3R4IFNldHRpbmdzIG9iamVjdCBvZiB0aGUgaG9zdCBEYXRhVGFibGVcbiAqIEBwYXJhbSAge2Jvb2xlYW59IFtmb3JjZT1mYWxzZV0gRm9yY2UgdGhlIGRlLXNlbGVjdGlvbiB0byBoYXBwZW4sIHJlZ2FyZGxlc3NcbiAqICAgICBvZiBzZWxlY3Rpb24gc3R5bGVcbiAqIEBwcml2YXRlXG4gKi9cbmZ1bmN0aW9uIGNsZWFyKCBjdHgsIGZvcmNlIClcbntcblx0aWYgKCBmb3JjZSB8fCBjdHguX3NlbGVjdC5zdHlsZSA9PT0gJ3NpbmdsZScgKSB7XG5cdFx0dmFyIGFwaSA9IG5ldyBEYXRhVGFibGUuQXBpKCBjdHggKTtcblx0XHRcblx0XHRhcGkucm93cyggeyBzZWxlY3RlZDogdHJ1ZSB9ICkuZGVzZWxlY3QoKTtcblx0XHRhcGkuY29sdW1ucyggeyBzZWxlY3RlZDogdHJ1ZSB9ICkuZGVzZWxlY3QoKTtcblx0XHRhcGkuY2VsbHMoIHsgc2VsZWN0ZWQ6IHRydWUgfSApLmRlc2VsZWN0KCk7XG5cdH1cbn1cblxuLyoqXG4gKiBTZWxlY3QgaXRlbXMgYmFzZWQgb24gdGhlIGN1cnJlbnQgY29uZmlndXJhdGlvbiBmb3Igc3R5bGUgYW5kIGl0ZW1zLlxuICpcbiAqIEBwYXJhbSAge29iamVjdH0gICAgICAgICAgICAgZSAgICBNb3VzZSBldmVudCBvYmplY3RcbiAqIEBwYXJhbSAge0RhdGFUYWJsZXMuQXBpfSAgICAgZHQgICBEYXRhVGFibGVcbiAqIEBwYXJhbSAge0RhdGFUYWJsZS5zZXR0aW5nc30gY3R4ICBTZXR0aW5ncyBvYmplY3Qgb2YgdGhlIGhvc3QgRGF0YVRhYmxlXG4gKiBAcGFyYW0gIHtzdHJpbmd9ICAgICAgICAgICAgIHR5cGUgSXRlbXMgdG8gc2VsZWN0XG4gKiBAcGFyYW0gIHtpbnR8b2JqZWN0fSAgICAgICAgIGlkeCAgSW5kZXggb2YgdGhlIGl0ZW0gdG8gc2VsZWN0XG4gKiBAcHJpdmF0ZVxuICovXG5mdW5jdGlvbiB0eXBlU2VsZWN0ICggZSwgZHQsIGN0eCwgdHlwZSwgaWR4IClcbntcblx0dmFyIHN0eWxlID0gZHQuc2VsZWN0LnN0eWxlKCk7XG5cdHZhciB0b2dnbGVhYmxlID0gZHQuc2VsZWN0LnRvZ2dsZWFibGUoKTtcblx0dmFyIGlzU2VsZWN0ZWQgPSBkdFt0eXBlXSggaWR4LCB7IHNlbGVjdGVkOiB0cnVlIH0gKS5hbnkoKTtcblx0XG5cdGlmICggaXNTZWxlY3RlZCAmJiAhIHRvZ2dsZWFibGUgKSB7XG5cdFx0cmV0dXJuO1xuXHR9XG5cblx0aWYgKCBzdHlsZSA9PT0gJ29zJyApIHtcblx0XHRpZiAoIGUuY3RybEtleSB8fCBlLm1ldGFLZXkgKSB7XG5cdFx0XHQvLyBBZGQgb3IgcmVtb3ZlIGZyb20gdGhlIHNlbGVjdGlvblxuXHRcdFx0ZHRbdHlwZV0oIGlkeCApLnNlbGVjdCggISBpc1NlbGVjdGVkICk7XG5cdFx0fVxuXHRcdGVsc2UgaWYgKCBlLnNoaWZ0S2V5ICkge1xuXHRcdFx0aWYgKCB0eXBlID09PSAnY2VsbCcgKSB7XG5cdFx0XHRcdGNlbGxSYW5nZSggZHQsIGlkeCwgY3R4Ll9zZWxlY3RfbGFzdENlbGwgfHwgbnVsbCApO1xuXHRcdFx0fVxuXHRcdFx0ZWxzZSB7XG5cdFx0XHRcdHJvd0NvbHVtblJhbmdlKCBkdCwgdHlwZSwgaWR4LCBjdHguX3NlbGVjdF9sYXN0Q2VsbCA/XG5cdFx0XHRcdFx0Y3R4Ll9zZWxlY3RfbGFzdENlbGxbdHlwZV0gOlxuXHRcdFx0XHRcdG51bGxcblx0XHRcdFx0KTtcblx0XHRcdH1cblx0XHR9XG5cdFx0ZWxzZSB7XG5cdFx0XHQvLyBObyBjbWQgb3Igc2hpZnQgY2xpY2sgLSBkZXNlbGVjdCBpZiBzZWxlY3RlZCwgb3Igc2VsZWN0XG5cdFx0XHQvLyB0aGlzIHJvdyBvbmx5XG5cdFx0XHR2YXIgc2VsZWN0ZWQgPSBkdFt0eXBlKydzJ10oIHsgc2VsZWN0ZWQ6IHRydWUgfSApO1xuXG5cdFx0XHRpZiAoIGlzU2VsZWN0ZWQgJiYgc2VsZWN0ZWQuZmxhdHRlbigpLmxlbmd0aCA9PT0gMSApIHtcblx0XHRcdFx0ZHRbdHlwZV0oIGlkeCApLmRlc2VsZWN0KCk7XG5cdFx0XHR9XG5cdFx0XHRlbHNlIHtcblx0XHRcdFx0c2VsZWN0ZWQuZGVzZWxlY3QoKTtcblx0XHRcdFx0ZHRbdHlwZV0oIGlkeCApLnNlbGVjdCgpO1xuXHRcdFx0fVxuXHRcdH1cblx0fSBlbHNlIGlmICggc3R5bGUgPT0gJ211bHRpK3NoaWZ0JyApIHtcblx0XHRpZiAoIGUuc2hpZnRLZXkgKSB7XG5cdFx0XHRpZiAoIHR5cGUgPT09ICdjZWxsJyApIHtcblx0XHRcdFx0Y2VsbFJhbmdlKCBkdCwgaWR4LCBjdHguX3NlbGVjdF9sYXN0Q2VsbCB8fCBudWxsICk7XG5cdFx0XHR9XG5cdFx0XHRlbHNlIHtcblx0XHRcdFx0cm93Q29sdW1uUmFuZ2UoIGR0LCB0eXBlLCBpZHgsIGN0eC5fc2VsZWN0X2xhc3RDZWxsID9cblx0XHRcdFx0XHRjdHguX3NlbGVjdF9sYXN0Q2VsbFt0eXBlXSA6XG5cdFx0XHRcdFx0bnVsbFxuXHRcdFx0XHQpO1xuXHRcdFx0fVxuXHRcdH1cblx0XHRlbHNlIHtcblx0XHRcdGR0WyB0eXBlIF0oIGlkeCApLnNlbGVjdCggISBpc1NlbGVjdGVkICk7XG5cdFx0fVxuXHR9XG5cdGVsc2Uge1xuXHRcdGR0WyB0eXBlIF0oIGlkeCApLnNlbGVjdCggISBpc1NlbGVjdGVkICk7XG5cdH1cbn1cblxuZnVuY3Rpb24gX3NhZmVJZCggbm9kZSApIHtcblx0cmV0dXJuIG5vZGUuaWQucmVwbGFjZSgvW15hLXpBLVowLTlcXC1cXF9dL2csICctJyk7XG59XG5cblxuXG4vKiAqICogKiAqICogKiAqICogKiAqICogKiAqICogKiAqICogKiAqICogKiAqICogKiAqICogKiAqICogKiAqICogKiAqICogKiAqICogKlxuICogRGF0YVRhYmxlcyBzZWxlY3RvcnNcbiAqL1xuXG4vLyByb3cgYW5kIGNvbHVtbiBhcmUgYmFzaWNhbGx5IGlkZW50aWNhbCBqdXN0IGFzc2lnbmVkIHRvIGRpZmZlcmVudCBwcm9wZXJ0aWVzXG4vLyBhbmQgY2hlY2tpbmcgYSBkaWZmZXJlbnQgYXJyYXksIHNvIHdlIGNhbiBkeW5hbWljYWxseSBjcmVhdGUgdGhlIGZ1bmN0aW9ucyB0b1xuLy8gcmVkdWNlIHRoZSBjb2RlIHNpemVcbiQuZWFjaCggW1xuXHR7IHR5cGU6ICdyb3cnLCBwcm9wOiAnYW9EYXRhJyB9LFxuXHR7IHR5cGU6ICdjb2x1bW4nLCBwcm9wOiAnYW9Db2x1bW5zJyB9XG5dLCBmdW5jdGlvbiAoIGksIG8gKSB7XG5cdERhdGFUYWJsZS5leHQuc2VsZWN0b3JbIG8udHlwZSBdLnB1c2goIGZ1bmN0aW9uICggc2V0dGluZ3MsIG9wdHMsIGluZGV4ZXMgKSB7XG5cdFx0dmFyIHNlbGVjdGVkID0gb3B0cy5zZWxlY3RlZDtcblx0XHR2YXIgZGF0YTtcblx0XHR2YXIgb3V0ID0gW107XG5cblx0XHRpZiAoIHNlbGVjdGVkICE9PSB0cnVlICYmIHNlbGVjdGVkICE9PSBmYWxzZSApIHtcblx0XHRcdHJldHVybiBpbmRleGVzO1xuXHRcdH1cblxuXHRcdGZvciAoIHZhciBpPTAsIGllbj1pbmRleGVzLmxlbmd0aCA7IGk8aWVuIDsgaSsrICkge1xuXHRcdFx0ZGF0YSA9IHNldHRpbmdzWyBvLnByb3AgXVsgaW5kZXhlc1tpXSBdO1xuXG5cdFx0XHRpZiAoIChzZWxlY3RlZCA9PT0gdHJ1ZSAmJiBkYXRhLl9zZWxlY3Rfc2VsZWN0ZWQgPT09IHRydWUpIHx8XG5cdFx0XHQgICAgIChzZWxlY3RlZCA9PT0gZmFsc2UgJiYgISBkYXRhLl9zZWxlY3Rfc2VsZWN0ZWQgKVxuXHRcdFx0KSB7XG5cdFx0XHRcdG91dC5wdXNoKCBpbmRleGVzW2ldICk7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0cmV0dXJuIG91dDtcblx0fSApO1xufSApO1xuXG5EYXRhVGFibGUuZXh0LnNlbGVjdG9yLmNlbGwucHVzaCggZnVuY3Rpb24gKCBzZXR0aW5ncywgb3B0cywgY2VsbHMgKSB7XG5cdHZhciBzZWxlY3RlZCA9IG9wdHMuc2VsZWN0ZWQ7XG5cdHZhciByb3dEYXRhO1xuXHR2YXIgb3V0ID0gW107XG5cblx0aWYgKCBzZWxlY3RlZCA9PT0gdW5kZWZpbmVkICkge1xuXHRcdHJldHVybiBjZWxscztcblx0fVxuXG5cdGZvciAoIHZhciBpPTAsIGllbj1jZWxscy5sZW5ndGggOyBpPGllbiA7IGkrKyApIHtcblx0XHRyb3dEYXRhID0gc2V0dGluZ3MuYW9EYXRhWyBjZWxsc1tpXS5yb3cgXTtcblxuXHRcdGlmICggKHNlbGVjdGVkID09PSB0cnVlICYmIHJvd0RhdGEuX3NlbGVjdGVkX2NlbGxzICYmIHJvd0RhdGEuX3NlbGVjdGVkX2NlbGxzWyBjZWxsc1tpXS5jb2x1bW4gXSA9PT0gdHJ1ZSkgfHxcblx0XHQgICAgIChzZWxlY3RlZCA9PT0gZmFsc2UgJiYgKCAhIHJvd0RhdGEuX3NlbGVjdGVkX2NlbGxzIHx8ICEgcm93RGF0YS5fc2VsZWN0ZWRfY2VsbHNbIGNlbGxzW2ldLmNvbHVtbiBdICkgKVxuXHRcdCkge1xuXHRcdFx0b3V0LnB1c2goIGNlbGxzW2ldICk7XG5cdFx0fVxuXHR9XG5cblx0cmV0dXJuIG91dDtcbn0gKTtcblxuXG5cbi8qICogKiAqICogKiAqICogKiAqICogKiAqICogKiAqICogKiAqICogKiAqICogKiAqICogKiAqICogKiAqICogKiAqICogKiAqICogKiAqXG4gKiBEYXRhVGFibGVzIEFQSVxuICpcbiAqIEZvciBjb21wbGV0ZSBkb2N1bWVudGF0aW9uLCBwbGVhc2UgcmVmZXIgdG8gdGhlIGRvY3MvYXBpIGRpcmVjdG9yeSBvciB0aGVcbiAqIERhdGFUYWJsZXMgc2l0ZVxuICovXG5cbi8vIExvY2FsIHZhcmlhYmxlcyB0byBpbXByb3ZlIGNvbXByZXNzaW9uXG52YXIgYXBpUmVnaXN0ZXIgPSBEYXRhVGFibGUuQXBpLnJlZ2lzdGVyO1xudmFyIGFwaVJlZ2lzdGVyUGx1cmFsID0gRGF0YVRhYmxlLkFwaS5yZWdpc3RlclBsdXJhbDtcblxuYXBpUmVnaXN0ZXIoICdzZWxlY3QoKScsIGZ1bmN0aW9uICgpIHtcblx0cmV0dXJuIHRoaXMuaXRlcmF0b3IoICd0YWJsZScsIGZ1bmN0aW9uICggY3R4ICkge1xuXHRcdERhdGFUYWJsZS5zZWxlY3QuaW5pdCggbmV3IERhdGFUYWJsZS5BcGkoIGN0eCApICk7XG5cdH0gKTtcbn0gKTtcblxuYXBpUmVnaXN0ZXIoICdzZWxlY3QuYmx1cmFibGUoKScsIGZ1bmN0aW9uICggZmxhZyApIHtcblx0aWYgKCBmbGFnID09PSB1bmRlZmluZWQgKSB7XG5cdFx0cmV0dXJuIHRoaXMuY29udGV4dFswXS5fc2VsZWN0LmJsdXJhYmxlO1xuXHR9XG5cblx0cmV0dXJuIHRoaXMuaXRlcmF0b3IoICd0YWJsZScsIGZ1bmN0aW9uICggY3R4ICkge1xuXHRcdGN0eC5fc2VsZWN0LmJsdXJhYmxlID0gZmxhZztcblx0fSApO1xufSApO1xuXG5hcGlSZWdpc3RlciggJ3NlbGVjdC50b2dnbGVhYmxlKCknLCBmdW5jdGlvbiAoIGZsYWcgKSB7XG5cdGlmICggZmxhZyA9PT0gdW5kZWZpbmVkICkge1xuXHRcdHJldHVybiB0aGlzLmNvbnRleHRbMF0uX3NlbGVjdC50b2dnbGVhYmxlO1xuXHR9XG5cblx0cmV0dXJuIHRoaXMuaXRlcmF0b3IoICd0YWJsZScsIGZ1bmN0aW9uICggY3R4ICkge1xuXHRcdGN0eC5fc2VsZWN0LnRvZ2dsZWFibGUgPSBmbGFnO1xuXHR9ICk7XG59ICk7XG5cbmFwaVJlZ2lzdGVyKCAnc2VsZWN0LmluZm8oKScsIGZ1bmN0aW9uICggZmxhZyApIHtcblx0aWYgKCBmbGFnID09PSB1bmRlZmluZWQgKSB7XG5cdFx0cmV0dXJuIHRoaXMuY29udGV4dFswXS5fc2VsZWN0LmluZm87XG5cdH1cblxuXHRyZXR1cm4gdGhpcy5pdGVyYXRvciggJ3RhYmxlJywgZnVuY3Rpb24gKCBjdHggKSB7XG5cdFx0Y3R4Ll9zZWxlY3QuaW5mbyA9IGZsYWc7XG5cdH0gKTtcbn0gKTtcblxuYXBpUmVnaXN0ZXIoICdzZWxlY3QuaXRlbXMoKScsIGZ1bmN0aW9uICggaXRlbXMgKSB7XG5cdGlmICggaXRlbXMgPT09IHVuZGVmaW5lZCApIHtcblx0XHRyZXR1cm4gdGhpcy5jb250ZXh0WzBdLl9zZWxlY3QuaXRlbXM7XG5cdH1cblxuXHRyZXR1cm4gdGhpcy5pdGVyYXRvciggJ3RhYmxlJywgZnVuY3Rpb24gKCBjdHggKSB7XG5cdFx0Y3R4Ll9zZWxlY3QuaXRlbXMgPSBpdGVtcztcblxuXHRcdGV2ZW50VHJpZ2dlciggbmV3IERhdGFUYWJsZS5BcGkoIGN0eCApLCAnc2VsZWN0SXRlbXMnLCBbIGl0ZW1zIF0gKTtcblx0fSApO1xufSApO1xuXG4vLyBUYWtlcyBlZmZlY3QgZnJvbSB0aGUgX25leHRfIHNlbGVjdGlvbi4gTm9uZSBkaXNhYmxlcyBmdXR1cmUgc2VsZWN0aW9uLCBidXRcbi8vIGRvZXMgbm90IGNsZWFyIHRoZSBjdXJyZW50IHNlbGVjdGlvbi4gVXNlIHRoZSBgZGVzZWxlY3RgIG1ldGhvZHMgZm9yIHRoYXRcbmFwaVJlZ2lzdGVyKCAnc2VsZWN0LnN0eWxlKCknLCBmdW5jdGlvbiAoIHN0eWxlICkge1xuXHRpZiAoIHN0eWxlID09PSB1bmRlZmluZWQgKSB7XG5cdFx0cmV0dXJuIHRoaXMuY29udGV4dFswXS5fc2VsZWN0LnN0eWxlO1xuXHR9XG5cblx0cmV0dXJuIHRoaXMuaXRlcmF0b3IoICd0YWJsZScsIGZ1bmN0aW9uICggY3R4ICkge1xuXHRcdGlmICggISBjdHguX3NlbGVjdCApIHtcblx0XHRcdERhdGFUYWJsZS5zZWxlY3QuaW5pdCggbmV3IERhdGFUYWJsZS5BcGkoY3R4KSApO1xuXHRcdH1cblxuXHRcdGlmICggISBjdHguX3NlbGVjdF9pbml0ICkge1xuXHRcdFx0aW5pdChjdHgpO1xuXHRcdH1cblxuXHRcdGN0eC5fc2VsZWN0LnN0eWxlID0gc3R5bGU7XG5cblx0XHQvLyBBZGQgLyByZW1vdmUgbW91c2UgZXZlbnQgaGFuZGxlcnMuIFRoZXkgYXJlbid0IHJlcXVpcmVkIHdoZW4gb25seVxuXHRcdC8vIEFQSSBzZWxlY3Rpb24gaXMgYXZhaWxhYmxlXG5cdFx0dmFyIGR0ID0gbmV3IERhdGFUYWJsZS5BcGkoIGN0eCApO1xuXHRcdGRpc2FibGVNb3VzZVNlbGVjdGlvbiggZHQgKTtcblx0XHRcblx0XHRpZiAoIHN0eWxlICE9PSAnYXBpJyApIHtcblx0XHRcdGVuYWJsZU1vdXNlU2VsZWN0aW9uKCBkdCApO1xuXHRcdH1cblxuXHRcdGV2ZW50VHJpZ2dlciggbmV3IERhdGFUYWJsZS5BcGkoIGN0eCApLCAnc2VsZWN0U3R5bGUnLCBbIHN0eWxlIF0gKTtcblx0fSApO1xufSApO1xuXG5hcGlSZWdpc3RlciggJ3NlbGVjdC5zZWxlY3RvcigpJywgZnVuY3Rpb24gKCBzZWxlY3RvciApIHtcblx0aWYgKCBzZWxlY3RvciA9PT0gdW5kZWZpbmVkICkge1xuXHRcdHJldHVybiB0aGlzLmNvbnRleHRbMF0uX3NlbGVjdC5zZWxlY3Rvcjtcblx0fVxuXG5cdHJldHVybiB0aGlzLml0ZXJhdG9yKCAndGFibGUnLCBmdW5jdGlvbiAoIGN0eCApIHtcblx0XHRkaXNhYmxlTW91c2VTZWxlY3Rpb24oIG5ldyBEYXRhVGFibGUuQXBpKCBjdHggKSApO1xuXG5cdFx0Y3R4Ll9zZWxlY3Quc2VsZWN0b3IgPSBzZWxlY3RvcjtcblxuXHRcdGlmICggY3R4Ll9zZWxlY3Quc3R5bGUgIT09ICdhcGknICkge1xuXHRcdFx0ZW5hYmxlTW91c2VTZWxlY3Rpb24oIG5ldyBEYXRhVGFibGUuQXBpKCBjdHggKSApO1xuXHRcdH1cblx0fSApO1xufSApO1xuXG5cblxuYXBpUmVnaXN0ZXJQbHVyYWwoICdyb3dzKCkuc2VsZWN0KCknLCAncm93KCkuc2VsZWN0KCknLCBmdW5jdGlvbiAoIHNlbGVjdCApIHtcblx0dmFyIGFwaSA9IHRoaXM7XG5cblx0aWYgKCBzZWxlY3QgPT09IGZhbHNlICkge1xuXHRcdHJldHVybiB0aGlzLmRlc2VsZWN0KCk7XG5cdH1cblxuXHR0aGlzLml0ZXJhdG9yKCAncm93JywgZnVuY3Rpb24gKCBjdHgsIGlkeCApIHtcblx0XHRjbGVhciggY3R4ICk7XG5cblx0XHRjdHguYW9EYXRhWyBpZHggXS5fc2VsZWN0X3NlbGVjdGVkID0gdHJ1ZTtcblx0XHQkKCBjdHguYW9EYXRhWyBpZHggXS5uVHIgKS5hZGRDbGFzcyggY3R4Ll9zZWxlY3QuY2xhc3NOYW1lICk7XG5cdH0gKTtcblxuXHR0aGlzLml0ZXJhdG9yKCAndGFibGUnLCBmdW5jdGlvbiAoIGN0eCwgaSApIHtcblx0XHRldmVudFRyaWdnZXIoIGFwaSwgJ3NlbGVjdCcsIFsgJ3JvdycsIGFwaVtpXSBdLCB0cnVlICk7XG5cdH0gKTtcblxuXHRyZXR1cm4gdGhpcztcbn0gKTtcblxuYXBpUmVnaXN0ZXJQbHVyYWwoICdjb2x1bW5zKCkuc2VsZWN0KCknLCAnY29sdW1uKCkuc2VsZWN0KCknLCBmdW5jdGlvbiAoIHNlbGVjdCApIHtcblx0dmFyIGFwaSA9IHRoaXM7XG5cblx0aWYgKCBzZWxlY3QgPT09IGZhbHNlICkge1xuXHRcdHJldHVybiB0aGlzLmRlc2VsZWN0KCk7XG5cdH1cblxuXHR0aGlzLml0ZXJhdG9yKCAnY29sdW1uJywgZnVuY3Rpb24gKCBjdHgsIGlkeCApIHtcblx0XHRjbGVhciggY3R4ICk7XG5cblx0XHRjdHguYW9Db2x1bW5zWyBpZHggXS5fc2VsZWN0X3NlbGVjdGVkID0gdHJ1ZTtcblxuXHRcdHZhciBjb2x1bW4gPSBuZXcgRGF0YVRhYmxlLkFwaSggY3R4ICkuY29sdW1uKCBpZHggKTtcblxuXHRcdCQoIGNvbHVtbi5oZWFkZXIoKSApLmFkZENsYXNzKCBjdHguX3NlbGVjdC5jbGFzc05hbWUgKTtcblx0XHQkKCBjb2x1bW4uZm9vdGVyKCkgKS5hZGRDbGFzcyggY3R4Ll9zZWxlY3QuY2xhc3NOYW1lICk7XG5cblx0XHRjb2x1bW4ubm9kZXMoKS50byQoKS5hZGRDbGFzcyggY3R4Ll9zZWxlY3QuY2xhc3NOYW1lICk7XG5cdH0gKTtcblxuXHR0aGlzLml0ZXJhdG9yKCAndGFibGUnLCBmdW5jdGlvbiAoIGN0eCwgaSApIHtcblx0XHRldmVudFRyaWdnZXIoIGFwaSwgJ3NlbGVjdCcsIFsgJ2NvbHVtbicsIGFwaVtpXSBdLCB0cnVlICk7XG5cdH0gKTtcblxuXHRyZXR1cm4gdGhpcztcbn0gKTtcblxuYXBpUmVnaXN0ZXJQbHVyYWwoICdjZWxscygpLnNlbGVjdCgpJywgJ2NlbGwoKS5zZWxlY3QoKScsIGZ1bmN0aW9uICggc2VsZWN0ICkge1xuXHR2YXIgYXBpID0gdGhpcztcblxuXHRpZiAoIHNlbGVjdCA9PT0gZmFsc2UgKSB7XG5cdFx0cmV0dXJuIHRoaXMuZGVzZWxlY3QoKTtcblx0fVxuXG5cdHRoaXMuaXRlcmF0b3IoICdjZWxsJywgZnVuY3Rpb24gKCBjdHgsIHJvd0lkeCwgY29sSWR4ICkge1xuXHRcdGNsZWFyKCBjdHggKTtcblxuXHRcdHZhciBkYXRhID0gY3R4LmFvRGF0YVsgcm93SWR4IF07XG5cblx0XHRpZiAoIGRhdGEuX3NlbGVjdGVkX2NlbGxzID09PSB1bmRlZmluZWQgKSB7XG5cdFx0XHRkYXRhLl9zZWxlY3RlZF9jZWxscyA9IFtdO1xuXHRcdH1cblxuXHRcdGRhdGEuX3NlbGVjdGVkX2NlbGxzWyBjb2xJZHggXSA9IHRydWU7XG5cblx0XHRpZiAoIGRhdGEuYW5DZWxscyApIHtcblx0XHRcdCQoIGRhdGEuYW5DZWxsc1sgY29sSWR4IF0gKS5hZGRDbGFzcyggY3R4Ll9zZWxlY3QuY2xhc3NOYW1lICk7XG5cdFx0fVxuXHR9ICk7XG5cblx0dGhpcy5pdGVyYXRvciggJ3RhYmxlJywgZnVuY3Rpb24gKCBjdHgsIGkgKSB7XG5cdFx0ZXZlbnRUcmlnZ2VyKCBhcGksICdzZWxlY3QnLCBbICdjZWxsJywgYXBpLmNlbGxzKGFwaVtpXSkuaW5kZXhlcygpLnRvQXJyYXkoKSBdLCB0cnVlICk7XG5cdH0gKTtcblxuXHRyZXR1cm4gdGhpcztcbn0gKTtcblxuXG5hcGlSZWdpc3RlclBsdXJhbCggJ3Jvd3MoKS5kZXNlbGVjdCgpJywgJ3JvdygpLmRlc2VsZWN0KCknLCBmdW5jdGlvbiAoKSB7XG5cdHZhciBhcGkgPSB0aGlzO1xuXG5cdHRoaXMuaXRlcmF0b3IoICdyb3cnLCBmdW5jdGlvbiAoIGN0eCwgaWR4ICkge1xuXHRcdGN0eC5hb0RhdGFbIGlkeCBdLl9zZWxlY3Rfc2VsZWN0ZWQgPSBmYWxzZTtcblx0XHRjdHguX3NlbGVjdF9sYXN0Q2VsbCA9IG51bGw7XG5cdFx0JCggY3R4LmFvRGF0YVsgaWR4IF0ublRyICkucmVtb3ZlQ2xhc3MoIGN0eC5fc2VsZWN0LmNsYXNzTmFtZSApO1xuXHR9ICk7XG5cblx0dGhpcy5pdGVyYXRvciggJ3RhYmxlJywgZnVuY3Rpb24gKCBjdHgsIGkgKSB7XG5cdFx0ZXZlbnRUcmlnZ2VyKCBhcGksICdkZXNlbGVjdCcsIFsgJ3JvdycsIGFwaVtpXSBdLCB0cnVlICk7XG5cdH0gKTtcblxuXHRyZXR1cm4gdGhpcztcbn0gKTtcblxuYXBpUmVnaXN0ZXJQbHVyYWwoICdjb2x1bW5zKCkuZGVzZWxlY3QoKScsICdjb2x1bW4oKS5kZXNlbGVjdCgpJywgZnVuY3Rpb24gKCkge1xuXHR2YXIgYXBpID0gdGhpcztcblxuXHR0aGlzLml0ZXJhdG9yKCAnY29sdW1uJywgZnVuY3Rpb24gKCBjdHgsIGlkeCApIHtcblx0XHRjdHguYW9Db2x1bW5zWyBpZHggXS5fc2VsZWN0X3NlbGVjdGVkID0gZmFsc2U7XG5cblx0XHR2YXIgYXBpID0gbmV3IERhdGFUYWJsZS5BcGkoIGN0eCApO1xuXHRcdHZhciBjb2x1bW4gPSBhcGkuY29sdW1uKCBpZHggKTtcblxuXHRcdCQoIGNvbHVtbi5oZWFkZXIoKSApLnJlbW92ZUNsYXNzKCBjdHguX3NlbGVjdC5jbGFzc05hbWUgKTtcblx0XHQkKCBjb2x1bW4uZm9vdGVyKCkgKS5yZW1vdmVDbGFzcyggY3R4Ll9zZWxlY3QuY2xhc3NOYW1lICk7XG5cblx0XHQvLyBOZWVkIHRvIGxvb3Agb3ZlciBlYWNoIGNlbGwsIHJhdGhlciB0aGFuIGp1c3QgdXNpbmdcblx0XHQvLyBgY29sdW1uKCkubm9kZXMoKWAgYXMgY2VsbHMgd2hpY2ggYXJlIGluZGl2aWR1YWxseSBzZWxlY3RlZCBzaG91bGRcblx0XHQvLyBub3QgaGF2ZSB0aGUgYHNlbGVjdGVkYCBjbGFzcyByZW1vdmVkIGZyb20gdGhlbVxuXHRcdGFwaS5jZWxscyggbnVsbCwgaWR4ICkuaW5kZXhlcygpLmVhY2goIGZ1bmN0aW9uIChjZWxsSWR4KSB7XG5cdFx0XHR2YXIgZGF0YSA9IGN0eC5hb0RhdGFbIGNlbGxJZHgucm93IF07XG5cdFx0XHR2YXIgY2VsbFNlbGVjdGVkID0gZGF0YS5fc2VsZWN0ZWRfY2VsbHM7XG5cblx0XHRcdGlmICggZGF0YS5hbkNlbGxzICYmICghIGNlbGxTZWxlY3RlZCB8fCAhIGNlbGxTZWxlY3RlZFsgY2VsbElkeC5jb2x1bW4gXSkgKSB7XG5cdFx0XHRcdCQoIGRhdGEuYW5DZWxsc1sgY2VsbElkeC5jb2x1bW4gIF0gKS5yZW1vdmVDbGFzcyggY3R4Ll9zZWxlY3QuY2xhc3NOYW1lICk7XG5cdFx0XHR9XG5cdFx0fSApO1xuXHR9ICk7XG5cblx0dGhpcy5pdGVyYXRvciggJ3RhYmxlJywgZnVuY3Rpb24gKCBjdHgsIGkgKSB7XG5cdFx0ZXZlbnRUcmlnZ2VyKCBhcGksICdkZXNlbGVjdCcsIFsgJ2NvbHVtbicsIGFwaVtpXSBdLCB0cnVlICk7XG5cdH0gKTtcblxuXHRyZXR1cm4gdGhpcztcbn0gKTtcblxuYXBpUmVnaXN0ZXJQbHVyYWwoICdjZWxscygpLmRlc2VsZWN0KCknLCAnY2VsbCgpLmRlc2VsZWN0KCknLCBmdW5jdGlvbiAoKSB7XG5cdHZhciBhcGkgPSB0aGlzO1xuXG5cdHRoaXMuaXRlcmF0b3IoICdjZWxsJywgZnVuY3Rpb24gKCBjdHgsIHJvd0lkeCwgY29sSWR4ICkge1xuXHRcdHZhciBkYXRhID0gY3R4LmFvRGF0YVsgcm93SWR4IF07XG5cblx0XHRpZihkYXRhLl9zZWxlY3RlZF9jZWxscyAhPT0gdW5kZWZpbmVkKSB7XG5cdFx0XHRkYXRhLl9zZWxlY3RlZF9jZWxsc1sgY29sSWR4IF0gPSBmYWxzZTtcblx0XHR9XG5cblx0XHQvLyBSZW1vdmUgY2xhc3Mgb25seSBpZiB0aGUgY2VsbHMgZXhpc3QsIGFuZCB0aGUgY2VsbCBpcyBub3QgY29sdW1uXG5cdFx0Ly8gc2VsZWN0ZWQsIGluIHdoaWNoIGNhc2UgdGhlIGNsYXNzIHNob3VsZCByZW1haW4gKHNpbmNlIGl0IGlzIHNlbGVjdGVkXG5cdFx0Ly8gaW4gdGhlIGNvbHVtbilcblx0XHRpZiAoIGRhdGEuYW5DZWxscyAmJiAhIGN0eC5hb0NvbHVtbnNbIGNvbElkeCBdLl9zZWxlY3Rfc2VsZWN0ZWQgKSB7XG5cdFx0XHQkKCBkYXRhLmFuQ2VsbHNbIGNvbElkeCBdICkucmVtb3ZlQ2xhc3MoIGN0eC5fc2VsZWN0LmNsYXNzTmFtZSApO1xuXHRcdH1cblx0fSApO1xuXG5cdHRoaXMuaXRlcmF0b3IoICd0YWJsZScsIGZ1bmN0aW9uICggY3R4LCBpICkge1xuXHRcdGV2ZW50VHJpZ2dlciggYXBpLCAnZGVzZWxlY3QnLCBbICdjZWxsJywgYXBpW2ldIF0sIHRydWUgKTtcblx0fSApO1xuXG5cdHJldHVybiB0aGlzO1xufSApO1xuXG5cblxuLyogKiAqICogKiAqICogKiAqICogKiAqICogKiAqICogKiAqICogKiAqICogKiAqICogKiAqICogKiAqICogKiAqICogKiAqICogKiAqICpcbiAqIEJ1dHRvbnNcbiAqL1xuZnVuY3Rpb24gaTE4biggbGFiZWwsIGRlZiApIHtcblx0cmV0dXJuIGZ1bmN0aW9uIChkdCkge1xuXHRcdHJldHVybiBkdC5pMThuKCAnYnV0dG9ucy4nK2xhYmVsLCBkZWYgKTtcblx0fTtcbn1cblxuLy8gQ29tbW9uIGV2ZW50cyB3aXRoIHN1aXRhYmxlIG5hbWVzcGFjZXNcbmZ1bmN0aW9uIG5hbWVzcGFjZWRFdmVudHMgKCBjb25maWcgKSB7XG5cdHZhciB1bmlxdWUgPSBjb25maWcuX2V2ZW50TmFtZXNwYWNlO1xuXG5cdHJldHVybiAnZHJhdy5kdC5EVCcrdW5pcXVlKycgc2VsZWN0LmR0LkRUJyt1bmlxdWUrJyBkZXNlbGVjdC5kdC5EVCcrdW5pcXVlO1xufVxuXG5mdW5jdGlvbiBlbmFibGVkICggZHQsIGNvbmZpZyApIHtcblx0aWYgKCAkLmluQXJyYXkoICdyb3dzJywgY29uZmlnLmxpbWl0VG8gKSAhPT0gLTEgJiYgZHQucm93cyggeyBzZWxlY3RlZDogdHJ1ZSB9ICkuYW55KCkgKSB7XG5cdFx0cmV0dXJuIHRydWU7XG5cdH1cblxuXHRpZiAoICQuaW5BcnJheSggJ2NvbHVtbnMnLCBjb25maWcubGltaXRUbyApICE9PSAtMSAmJiBkdC5jb2x1bW5zKCB7IHNlbGVjdGVkOiB0cnVlIH0gKS5hbnkoKSApIHtcblx0XHRyZXR1cm4gdHJ1ZTtcblx0fVxuXG5cdGlmICggJC5pbkFycmF5KCAnY2VsbHMnLCBjb25maWcubGltaXRUbyApICE9PSAtMSAmJiBkdC5jZWxscyggeyBzZWxlY3RlZDogdHJ1ZSB9ICkuYW55KCkgKSB7XG5cdFx0cmV0dXJuIHRydWU7XG5cdH1cblxuXHRyZXR1cm4gZmFsc2U7XG59XG5cbnZhciBfYnV0dG9uTmFtZXNwYWNlID0gMDtcblxuJC5leHRlbmQoIERhdGFUYWJsZS5leHQuYnV0dG9ucywge1xuXHRzZWxlY3RlZDoge1xuXHRcdHRleHQ6IGkxOG4oICdzZWxlY3RlZCcsICdTZWxlY3RlZCcgKSxcblx0XHRjbGFzc05hbWU6ICdidXR0b25zLXNlbGVjdGVkJyxcblx0XHRsaW1pdFRvOiBbICdyb3dzJywgJ2NvbHVtbnMnLCAnY2VsbHMnIF0sXG5cdFx0aW5pdDogZnVuY3Rpb24gKCBkdCwgbm9kZSwgY29uZmlnICkge1xuXHRcdFx0dmFyIHRoYXQgPSB0aGlzO1xuXHRcdFx0Y29uZmlnLl9ldmVudE5hbWVzcGFjZSA9ICcuc2VsZWN0JysoX2J1dHRvbk5hbWVzcGFjZSsrKTtcblxuXHRcdFx0Ly8gLkRUIG5hbWVzcGFjZSBsaXN0ZW5lcnMgYXJlIHJlbW92ZWQgYnkgRGF0YVRhYmxlcyBhdXRvbWF0aWNhbGx5XG5cdFx0XHQvLyBvbiB0YWJsZSBkZXN0cm95XG5cdFx0XHRkdC5vbiggbmFtZXNwYWNlZEV2ZW50cyhjb25maWcpLCBmdW5jdGlvbiAoKSB7XG5cdFx0XHRcdHRoYXQuZW5hYmxlKCBlbmFibGVkKGR0LCBjb25maWcpICk7XG5cdFx0XHR9ICk7XG5cblx0XHRcdHRoaXMuZGlzYWJsZSgpO1xuXHRcdH0sXG5cdFx0ZGVzdHJveTogZnVuY3Rpb24gKCBkdCwgbm9kZSwgY29uZmlnICkge1xuXHRcdFx0ZHQub2ZmKCBjb25maWcuX2V2ZW50TmFtZXNwYWNlICk7XG5cdFx0fVxuXHR9LFxuXHRzZWxlY3RlZFNpbmdsZToge1xuXHRcdHRleHQ6IGkxOG4oICdzZWxlY3RlZFNpbmdsZScsICdTZWxlY3RlZCBzaW5nbGUnICksXG5cdFx0Y2xhc3NOYW1lOiAnYnV0dG9ucy1zZWxlY3RlZC1zaW5nbGUnLFxuXHRcdGluaXQ6IGZ1bmN0aW9uICggZHQsIG5vZGUsIGNvbmZpZyApIHtcblx0XHRcdHZhciB0aGF0ID0gdGhpcztcblx0XHRcdGNvbmZpZy5fZXZlbnROYW1lc3BhY2UgPSAnLnNlbGVjdCcrKF9idXR0b25OYW1lc3BhY2UrKyk7XG5cblx0XHRcdGR0Lm9uKCBuYW1lc3BhY2VkRXZlbnRzKGNvbmZpZyksIGZ1bmN0aW9uICgpIHtcblx0XHRcdFx0dmFyIGNvdW50ID0gZHQucm93cyggeyBzZWxlY3RlZDogdHJ1ZSB9ICkuZmxhdHRlbigpLmxlbmd0aCArXG5cdFx0XHRcdCAgICAgICAgICAgIGR0LmNvbHVtbnMoIHsgc2VsZWN0ZWQ6IHRydWUgfSApLmZsYXR0ZW4oKS5sZW5ndGggK1xuXHRcdFx0XHQgICAgICAgICAgICBkdC5jZWxscyggeyBzZWxlY3RlZDogdHJ1ZSB9ICkuZmxhdHRlbigpLmxlbmd0aDtcblxuXHRcdFx0XHR0aGF0LmVuYWJsZSggY291bnQgPT09IDEgKTtcblx0XHRcdH0gKTtcblxuXHRcdFx0dGhpcy5kaXNhYmxlKCk7XG5cdFx0fSxcblx0XHRkZXN0cm95OiBmdW5jdGlvbiAoIGR0LCBub2RlLCBjb25maWcgKSB7XG5cdFx0XHRkdC5vZmYoIGNvbmZpZy5fZXZlbnROYW1lc3BhY2UgKTtcblx0XHR9XG5cdH0sXG5cdHNlbGVjdEFsbDoge1xuXHRcdHRleHQ6IGkxOG4oICdzZWxlY3RBbGwnLCAnU2VsZWN0IGFsbCcgKSxcblx0XHRjbGFzc05hbWU6ICdidXR0b25zLXNlbGVjdC1hbGwnLFxuXHRcdGFjdGlvbjogZnVuY3Rpb24gKCkge1xuXHRcdFx0dmFyIGl0ZW1zID0gdGhpcy5zZWxlY3QuaXRlbXMoKTtcblx0XHRcdHRoaXNbIGl0ZW1zKydzJyBdKCkuc2VsZWN0KCk7XG5cdFx0fVxuXHR9LFxuXHRzZWxlY3ROb25lOiB7XG5cdFx0dGV4dDogaTE4biggJ3NlbGVjdE5vbmUnLCAnRGVzZWxlY3QgYWxsJyApLFxuXHRcdGNsYXNzTmFtZTogJ2J1dHRvbnMtc2VsZWN0LW5vbmUnLFxuXHRcdGFjdGlvbjogZnVuY3Rpb24gKCkge1xuXHRcdFx0Y2xlYXIoIHRoaXMuc2V0dGluZ3MoKVswXSwgdHJ1ZSApO1xuXHRcdH0sXG5cdFx0aW5pdDogZnVuY3Rpb24gKCBkdCwgbm9kZSwgY29uZmlnICkge1xuXHRcdFx0dmFyIHRoYXQgPSB0aGlzO1xuXHRcdFx0Y29uZmlnLl9ldmVudE5hbWVzcGFjZSA9ICcuc2VsZWN0JysoX2J1dHRvbk5hbWVzcGFjZSsrKTtcblxuXHRcdFx0ZHQub24oIG5hbWVzcGFjZWRFdmVudHMoY29uZmlnKSwgZnVuY3Rpb24gKCkge1xuXHRcdFx0XHR2YXIgY291bnQgPSBkdC5yb3dzKCB7IHNlbGVjdGVkOiB0cnVlIH0gKS5mbGF0dGVuKCkubGVuZ3RoICtcblx0XHRcdFx0ICAgICAgICAgICAgZHQuY29sdW1ucyggeyBzZWxlY3RlZDogdHJ1ZSB9ICkuZmxhdHRlbigpLmxlbmd0aCArXG5cdFx0XHRcdCAgICAgICAgICAgIGR0LmNlbGxzKCB7IHNlbGVjdGVkOiB0cnVlIH0gKS5mbGF0dGVuKCkubGVuZ3RoO1xuXG5cdFx0XHRcdHRoYXQuZW5hYmxlKCBjb3VudCA+IDAgKTtcblx0XHRcdH0gKTtcblxuXHRcdFx0dGhpcy5kaXNhYmxlKCk7XG5cdFx0fSxcblx0XHRkZXN0cm95OiBmdW5jdGlvbiAoIGR0LCBub2RlLCBjb25maWcgKSB7XG5cdFx0XHRkdC5vZmYoIGNvbmZpZy5fZXZlbnROYW1lc3BhY2UgKTtcblx0XHR9XG5cdH1cbn0gKTtcblxuJC5lYWNoKCBbICdSb3cnLCAnQ29sdW1uJywgJ0NlbGwnIF0sIGZ1bmN0aW9uICggaSwgaXRlbSApIHtcblx0dmFyIGxjID0gaXRlbS50b0xvd2VyQ2FzZSgpO1xuXG5cdERhdGFUYWJsZS5leHQuYnV0dG9uc1sgJ3NlbGVjdCcraXRlbSsncycgXSA9IHtcblx0XHR0ZXh0OiBpMThuKCAnc2VsZWN0JytpdGVtKydzJywgJ1NlbGVjdCAnK2xjKydzJyApLFxuXHRcdGNsYXNzTmFtZTogJ2J1dHRvbnMtc2VsZWN0LScrbGMrJ3MnLFxuXHRcdGFjdGlvbjogZnVuY3Rpb24gKCkge1xuXHRcdFx0dGhpcy5zZWxlY3QuaXRlbXMoIGxjICk7XG5cdFx0fSxcblx0XHRpbml0OiBmdW5jdGlvbiAoIGR0ICkge1xuXHRcdFx0dmFyIHRoYXQgPSB0aGlzO1xuXG5cdFx0XHRkdC5vbiggJ3NlbGVjdEl0ZW1zLmR0LkRUJywgZnVuY3Rpb24gKCBlLCBjdHgsIGl0ZW1zICkge1xuXHRcdFx0XHR0aGF0LmFjdGl2ZSggaXRlbXMgPT09IGxjICk7XG5cdFx0XHR9ICk7XG5cdFx0fVxuXHR9O1xufSApO1xuXG5cblxuLyogKiAqICogKiAqICogKiAqICogKiAqICogKiAqICogKiAqICogKiAqICogKiAqICogKiAqICogKiAqICogKiAqICogKiAqICogKiAqICpcbiAqIEluaXRpYWxpc2F0aW9uXG4gKi9cblxuLy8gRGF0YVRhYmxlcyBjcmVhdGlvbiAtIGNoZWNrIGlmIHNlbGVjdCBoYXMgYmVlbiBkZWZpbmVkIGluIHRoZSBvcHRpb25zLiBOb3RlXG4vLyB0aGlzIHJlcXVpcmVkIHRoYXQgdGhlIHRhYmxlIGJlIGluIHRoZSBkb2N1bWVudCEgSWYgaXQgaXNuJ3QgdGhlbiBzb21ldGhpbmdcbi8vIG5lZWRzIHRvIHRyaWdnZXIgdGhpcyBtZXRob2QgdW5mb3J0dW5hdGVseS4gVGhlIG5leHQgbWFqb3IgcmVsZWFzZSBvZlxuLy8gRGF0YVRhYmxlcyB3aWxsIHJld29yayB0aGUgZXZlbnRzIGFuZCBhZGRyZXNzIHRoaXMuXG4kKGRvY3VtZW50KS5vbiggJ3ByZUluaXQuZHQuZHRTZWxlY3QnLCBmdW5jdGlvbiAoZSwgY3R4KSB7XG5cdGlmICggZS5uYW1lc3BhY2UgIT09ICdkdCcgKSB7XG5cdFx0cmV0dXJuO1xuXHR9XG5cblx0RGF0YVRhYmxlLnNlbGVjdC5pbml0KCBuZXcgRGF0YVRhYmxlLkFwaSggY3R4ICkgKTtcbn0gKTtcblxuXG5yZXR1cm4gRGF0YVRhYmxlLnNlbGVjdDtcbn0pKTtcbiJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/datatables.net-select/js/dataTables.select.js\n");

/***/ }),

/***/ "datatables.net":
/*!*********************************!*\
  !*** external "$.fn.dataTable" ***!
  \*********************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("(function() { module.exports = window[\"$.fn.dataTable\"]; }());//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vZXh0ZXJuYWwgXCIkLmZuLmRhdGFUYWJsZVwiPzgyMTEiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUEsYUFBYSwyQ0FBMkMsRUFBRSIsImZpbGUiOiJkYXRhdGFibGVzLm5ldC5qcyIsInNvdXJjZXNDb250ZW50IjpbIihmdW5jdGlvbigpIHsgbW9kdWxlLmV4cG9ydHMgPSB3aW5kb3dbXCIkLmZuLmRhdGFUYWJsZVwiXTsgfSgpKTsiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///datatables.net\n");

/***/ }),

/***/ "jquery":
/*!*************************!*\
  !*** external "jQuery" ***!
  \*************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("(function() { module.exports = window[\"jQuery\"]; }());//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vZXh0ZXJuYWwgXCJqUXVlcnlcIj9jZDBjIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBLGFBQWEsbUNBQW1DLEVBQUUiLCJmaWxlIjoianF1ZXJ5LmpzIiwic291cmNlc0NvbnRlbnQiOlsiKGZ1bmN0aW9uKCkgeyBtb2R1bGUuZXhwb3J0cyA9IHdpbmRvd1tcImpRdWVyeVwiXTsgfSgpKTsiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///jquery\n");

/***/ })

/******/ })));